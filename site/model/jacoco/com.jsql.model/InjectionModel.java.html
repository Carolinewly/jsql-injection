<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>InjectionModel.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">model</a> &gt; <a href="index.source.html" class="el_package">com.jsql.model</a> &gt; <span class="el_source">InjectionModel.java</span></div><h1>InjectionModel.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyhacked (H) 2012-2020.
 * This program and the accompanying materials
 * are made available under no term at all, use it like
 * you want, but share and discuss about it
 * every time possible with every body.
 * 
 * Contributors:
 *      ron190 at ymail dot com - initial implementation
 ******************************************************************************/
package com.jsql.model;

import com.jsql.model.accessible.DataAccess;
import com.jsql.model.accessible.ResourceAccess;
import com.jsql.model.bean.util.Header;
import com.jsql.model.bean.util.Interaction;
import com.jsql.model.bean.util.Request;
import com.jsql.model.exception.JSqlException;
import com.jsql.model.injection.method.AbstractMethodInjection;
import com.jsql.model.injection.method.MediatorMethod;
import com.jsql.model.injection.strategy.MediatorStrategy;
import com.jsql.model.injection.strategy.blind.AbstractCallableBoolean;
import com.jsql.model.injection.vendor.MediatorVendor;
import com.jsql.model.injection.vendor.model.VendorYaml;
import com.jsql.util.*;
import com.jsql.util.GitUtil.ShowOnConsole;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.SystemUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.io.Serializable;
import java.net.*;
import java.net.http.HttpRequest;
import java.net.http.HttpRequest.BodyPublishers;
import java.net.http.HttpRequest.Builder;
import java.net.http.HttpResponse;
import java.net.http.HttpResponse.BodyHandlers;
import java.nio.charset.StandardCharsets;
import java.text.DecimalFormat;
import java.time.Duration;
import java.util.AbstractMap.SimpleEntry;
import java.util.EnumMap;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * Model class of MVC pattern for processing SQL injection automatically.&lt;br&gt;
 * Different views can be attached to this observable, like Swing or command line, in order to separate
 * the functional job from the graphical processing.&lt;br&gt;
 * The Model has a specific database vendor and strategy which run an automatic injection to get name of
 * databases, tables, columns and values, and it can also retrieve resources like files and shell.&lt;br&gt;
 * Tasks are run in multi-threads in general to speed the process.
 */
public class InjectionModel extends AbstractModelObservable implements Serializable {
    
    /**
     * Log4j logger sent to view.
     */
<span class="fc" id="L63">    private static final Logger LOGGER = LogManager.getRootLogger();</span>
    
<span class="fc" id="L65">    private final transient MediatorVendor mediatorVendor = new MediatorVendor(this);</span>
<span class="fc" id="L66">    private final transient MediatorMethod mediatorMethod = new MediatorMethod(this);</span>
    private final transient MediatorUtils mediatorUtils;
    private final transient MediatorStrategy mediatorStrategy;

<span class="fc" id="L70">    private final transient PropertiesUtil propertiesUtil = new PropertiesUtil();</span>
             
<span class="fc" id="L72">    private final transient DataAccess dataAccess = new DataAccess(this);</span>
<span class="fc" id="L73">    private final transient ResourceAccess resourceAccess = new ResourceAccess(this);</span>
    
    public static final String STAR = &quot;*&quot;;
    
    /**
     * initialUrl transformed to a correct injection url.
     */
<span class="fc" id="L80">    private String indexesInUrl = StringUtils.EMPTY;</span>
<span class="fc" id="L81">    private String analysisReport = StringUtils.EMPTY;</span>

    /**
     * Allow to directly start an injection after a failed one
     * without asking the user 'Start a new injection?'.
     */
<span class="fc" id="L87">    private boolean shouldErasePreviousInjection = false;</span>

<span class="fc" id="L89">    private boolean isScanning = false;</span>

<span class="fc" id="L91">    public InjectionModel() {</span>
        
<span class="fc" id="L93">        this.mediatorUtils = new MediatorUtils();</span>
        
<span class="fc" id="L95">        this.mediatorStrategy = new MediatorStrategy(this);</span>

<span class="fc" id="L97">        this.mediatorUtils.setCertificateUtil(new CertificateUtil());</span>
<span class="fc" id="L98">        this.mediatorUtils.setPropertiesUtil(this.propertiesUtil);</span>
<span class="fc" id="L99">        this.mediatorUtils.setConnectionUtil(new ConnectionUtil(this));</span>
<span class="fc" id="L100">        this.mediatorUtils.setAuthenticationUtil(new AuthenticationUtil());</span>
<span class="fc" id="L101">        this.mediatorUtils.setGitUtil(new GitUtil(this));</span>
<span class="fc" id="L102">        this.mediatorUtils.setHeaderUtil(new HeaderUtil(this));</span>
<span class="fc" id="L103">        this.mediatorUtils.setParameterUtil(new ParameterUtil(this));</span>
<span class="fc" id="L104">        this.mediatorUtils.setExceptionUtil(new ExceptionUtil(this));</span>
<span class="fc" id="L105">        this.mediatorUtils.setSoapUtil(new SoapUtil(this));</span>
<span class="fc" id="L106">        this.mediatorUtils.setMultipartUtil(new MultipartUtil(this));</span>
<span class="fc" id="L107">        this.mediatorUtils.setCookiesUtil(new CookiesUtil(this));</span>
<span class="fc" id="L108">        this.mediatorUtils.setJsonUtil(new JsonUtil(this));</span>
<span class="fc" id="L109">        this.mediatorUtils.setPreferencesUtil(new PreferencesUtil());</span>
<span class="fc" id="L110">        this.mediatorUtils.setProxyUtil(new ProxyUtil(this));</span>
<span class="fc" id="L111">        this.mediatorUtils.setThreadUtil(new ThreadUtil(this));</span>
<span class="fc" id="L112">        this.mediatorUtils.setTamperingUtil(new TamperingUtil());</span>
<span class="fc" id="L113">        this.mediatorUtils.setUserAgentUtil(new UserAgentUtil());</span>
<span class="fc" id="L114">        this.mediatorUtils.setCsrfUtil(new CsrfUtil(this));</span>
<span class="fc" id="L115">        this.mediatorUtils.setFormUtil(new FormUtil(this));</span>
<span class="fc" id="L116">        this.mediatorUtils.setDigestUtil(new DigestUtil(this));</span>
<span class="fc" id="L117">    }</span>

    /**
     * Reset each injection attributes: Database metadata, General Thread status, Strategy.
     */
    public void resetModel() {
        
<span class="fc" id="L124">        this.mediatorStrategy.getNormal().setVisibleIndex(null);</span>
        
<span class="fc" id="L126">        this.mediatorStrategy.getNormal().setApplicable(false);</span>
<span class="fc" id="L127">        this.mediatorStrategy.getError().setApplicable(false);</span>
<span class="fc" id="L128">        this.mediatorStrategy.getBlind().setApplicable(false);</span>
<span class="fc" id="L129">        this.mediatorStrategy.getMultibit().setApplicable(false);</span>
<span class="fc" id="L130">        this.mediatorStrategy.getTime().setApplicable(false);</span>
<span class="fc" id="L131">        this.mediatorStrategy.getStacked().setApplicable(false);</span>
<span class="fc" id="L132">        this.mediatorStrategy.setStrategy(null);</span>

<span class="fc" id="L134">        this.indexesInUrl = StringUtils.EMPTY;</span>
<span class="fc" id="L135">        this.analysisReport = StringUtils.EMPTY;</span>
<span class="fc" id="L136">        this.isStoppedByUser = false;</span>
<span class="fc" id="L137">        this.shouldErasePreviousInjection = false;</span>

<span class="fc" id="L139">        this.mediatorUtils.getCsrfUtil().setTokenCsrf(null);</span>
<span class="fc" id="L140">        this.mediatorUtils.getDigestUtil().setTokenDigest(null);</span>
<span class="fc" id="L141">        this.mediatorUtils.getThreadUtil().reset();</span>
<span class="fc" id="L142">    }</span>

    /**
     * Prepare the injection process, can be interrupted by the user (via shouldStopAll).
     * Erase all attributes eventually defined in a previous injection.
     * Run by Scan, Standard and TU.
     */
    public void beginInjection() {
        
<span class="fc" id="L151">        this.resetModel();</span>
        
        try {
<span class="pc bpc" id="L154" title="1 of 2 branches missed.">            if (this.mediatorUtils.getProxyUtil().isNotLive(ShowOnConsole.YES)) {</span>
<span class="nc" id="L155">                return;</span>
            }
            
<span class="fc" id="L158">            LOGGER.log(</span>
                LogLevelUtil.CONSOLE_INFORM,
                &quot;{}: {}&quot;,
<span class="fc" id="L161">                () -&gt; I18nUtil.valueByKey(&quot;LOG_START_INJECTION&quot;),</span>
<span class="fc" id="L162">                () -&gt; this.mediatorUtils.getConnectionUtil().getUrlByUser()</span>
            );
            
            // Check general integrity if user's parameters
<span class="fc" id="L166">            this.mediatorUtils.getParameterUtil().checkParametersFormat();</span>
            
<span class="fc" id="L168">            this.mediatorUtils.getConnectionUtil().testConnection();</span>

            // TODO Check all path params
<span class="fc" id="L171">            boolean hasFoundInjection = this.mediatorMethod.getQuery().testParameters(false);</span>
<span class="fc" id="L172">            hasFoundInjection = this.mediatorUtils.getMultipartUtil().testParameters(hasFoundInjection);</span>
<span class="fc" id="L173">            hasFoundInjection = this.mediatorUtils.getSoapUtil().testParameters(hasFoundInjection);</span>
<span class="fc" id="L174">            hasFoundInjection = this.mediatorMethod.getRequest().testParameters(hasFoundInjection);</span>
<span class="fc" id="L175">            hasFoundInjection = this.mediatorMethod.getHeader().testParameters(hasFoundInjection);</span>
<span class="fc" id="L176">            hasFoundInjection = this.mediatorUtils.getCookiesUtil().testParameters(hasFoundInjection);</span>

<span class="pc bpc" id="L178" title="1 of 4 branches missed.">            if (hasFoundInjection &amp;&amp; !this.isScanning) {</span>

<span class="pc bpc" id="L180" title="1 of 2 branches missed.">                if (!this.getMediatorUtils().getPreferencesUtil().isNotShowingVulnReport()) {</span>

<span class="fc" id="L182">                    var requestSetVendor = new Request();</span>
<span class="fc" id="L183">                    requestSetVendor.setMessage(Interaction.CREATE_ANALYSIS_REPORT);</span>
<span class="fc" id="L184">                    requestSetVendor.setParameters(this.analysisReport);</span>
<span class="fc" id="L185">                    this.sendToViews(requestSetVendor);</span>
                }

<span class="fc bfc" id="L188" title="All 2 branches covered.">                if (this.getMediatorUtils().getPreferencesUtil().isZipStrategy()) {</span>
<span class="fc" id="L189">                    LOGGER.log(LogLevelUtil.CONSOLE_INFORM, &quot;Using Zip mode for reduced query size&quot;);</span>
<span class="fc bfc" id="L190" title="All 2 branches covered.">                } else if (this.getMediatorUtils().getPreferencesUtil().isDiosStrategy()) {</span>
<span class="fc" id="L191">                    LOGGER.log(LogLevelUtil.CONSOLE_INFORM, &quot;Using Dump In One Shot strategy for single query dump&quot;);</span>
                }
                
<span class="pc bpc" id="L194" title="1 of 2 branches missed.">                if (!this.mediatorUtils.getPreferencesUtil().isNotInjectingMetadata()) {</span>
<span class="fc" id="L195">                    this.dataAccess.getDatabaseInfos();</span>
                }
                
<span class="fc" id="L198">                this.dataAccess.listDatabases();</span>
            }
            
<span class="fc" id="L201">            LOGGER.log(LogLevelUtil.CONSOLE_DEFAULT, () -&gt; I18nUtil.valueByKey(&quot;LOG_DONE&quot;));</span>
            
<span class="fc" id="L203">            this.shouldErasePreviousInjection = true;</span>
            
<span class="nc" id="L205">        } catch (InterruptedException e) {</span>
            
<span class="nc" id="L207">            LOGGER.log(LogLevelUtil.IGNORE, e, e);</span>
<span class="nc" id="L208">            Thread.currentThread().interrupt();</span>
            
<span class="nc" id="L210">        } catch (JSqlException | IOException e) {  // Catch expected exceptions only</span>

<span class="nc bnc" id="L212" title="All 2 branches missed.">            if (e.getMessage() == null) {</span>
<span class="nc" id="L213">                LOGGER.log(LogLevelUtil.CONSOLE_ERROR, &quot;Unexpected: {}&quot;, getImplicitReason(e));</span>
            } else {
<span class="nc" id="L215">                LOGGER.log(LogLevelUtil.CONSOLE_ERROR, &quot;Unexpected: {}&quot;, e.getMessage());</span>
            }

<span class="nc bnc" id="L218" title="All 2 branches missed.">            if (e.toString().contains(&quot;HTTP/1.1&quot;)) {</span>
<span class="nc" id="L219">                LOGGER.log(LogLevelUtil.CONSOLE_ERROR, &quot;Something went wrong with HTTP/2, try to switch manually to HTTP/1.1 in preferences&quot;);</span>
            }
        } finally {
            
<span class="fc" id="L223">            var request = new Request();</span>
<span class="fc" id="L224">            request.setMessage(Interaction.END_PREPARATION);</span>
<span class="fc" id="L225">            this.sendToViews(request);</span>
        }
<span class="fc" id="L227">    }</span>
    
    public static String getImplicitReason(Throwable e) {
        
<span class="nc" id="L231">        String eMessage = e.getClass().getSimpleName();</span>
        
<span class="nc bnc" id="L233" title="All 2 branches missed.">        if (e.getMessage() != null) {</span>
<span class="nc" id="L234">            eMessage += &quot;: &quot;+ e.getMessage();</span>
        }
        
<span class="nc bnc" id="L237" title="All 4 branches missed.">        if (e.getCause() != null &amp;&amp; !e.equals(e.getCause())) {</span>
<span class="nc" id="L238">            eMessage += &quot; &gt; &quot;+ getImplicitReason(e.getCause());</span>
        }
        
<span class="nc" id="L241">        return eMessage;</span>
    }
    
    /**
     * Run a HTTP connection to the web server.
     * @param dataInjection SQL query
     * @return source code of current page
     */
    @Override
    public String inject(
        String dataInjection,
        boolean isUsingIndex,
        String metadataInjectionProcess,
        AbstractCallableBoolean&lt;?&gt; callableBoolean,
        boolean isReport
    ) {
        
        // Temporary url, we go from &quot;select 1,2,3,4...&quot; to &quot;select 1,([complex query]),2...&quot;, but keep initial url
<span class="fc" id="L259">        String urlInjection = this.mediatorUtils.getConnectionUtil().getUrlBase();</span>

<span class="fc" id="L261">        urlInjection = this.mediatorStrategy.buildPath(urlInjection, isUsingIndex, dataInjection);</span>
        
<span class="fc" id="L263">        urlInjection = StringUtil.cleanSql(urlInjection.trim());</span>

        URL urlObject;
        
        // TODO Keep only a single check
        try {
<span class="fc" id="L269">            urlObject = new URI(urlInjection).toURL();</span>
<span class="nc" id="L270">        } catch (MalformedURLException | URISyntaxException e) {</span>
            
<span class="nc" id="L272">            LOGGER.log(</span>
                LogLevelUtil.CONSOLE_ERROR,
<span class="nc" id="L274">                String.format(&quot;Incorrect Query Url: %s&quot;, e.getMessage())</span>
            );
<span class="nc" id="L276">            return StringUtils.EMPTY;</span>
<span class="fc" id="L277">        }</span>

<span class="fc" id="L279">        Map&lt;Header, Object&gt; msgHeader = new EnumMap&lt;&gt;(Header.class);</span>

        // TODO identique urlInjection == urlObject
<span class="fc" id="L282">        urlObject = this.initializeQueryString(</span>
            isUsingIndex,
            urlInjection,
            dataInjection,
            urlObject,
            msgHeader
        );
        
<span class="fc" id="L290">        String pageSource = StringUtils.EMPTY;</span>
        
        // Define the connection
        try {
<span class="fc" id="L294">            var httpRequestBuilder = HttpRequest.newBuilder()</span>
<span class="fc" id="L295">                .uri(URI.create(urlObject.toString()))</span>
<span class="fc" id="L296">                .setHeader(HeaderUtil.CONTENT_TYPE_REQUEST, &quot;text/plain&quot;)</span>
<span class="fc" id="L297">                .timeout(Duration.ofSeconds(15));</span>
            
<span class="fc" id="L299">            this.mediatorUtils.getCsrfUtil().addHeaderToken(httpRequestBuilder);</span>
<span class="fc" id="L300">            this.mediatorUtils.getDigestUtil().addHeaderToken(httpRequestBuilder);</span>

<span class="fc" id="L302">            this.mediatorUtils.getConnectionUtil().setCustomUserAgent(httpRequestBuilder);</span>

<span class="fc" id="L304">            String body = this.initializeRequest(isUsingIndex, dataInjection, httpRequestBuilder, msgHeader);</span>
<span class="fc" id="L305">            this.initializeHeader(isUsingIndex, dataInjection, httpRequestBuilder);</span>
            
<span class="fc" id="L307">            var httpRequest = httpRequestBuilder.build();</span>

<span class="fc bfc" id="L309" title="All 2 branches covered.">            if (isReport) {</span>

<span class="fc" id="L311">                String report = &quot;&lt;br&gt;&lt;span style=color:rgb(75,143,211)&gt;Method:&lt;/span&gt; &quot; + httpRequest.method();</span>
<span class="fc" id="L312">                report += &quot;&lt;br&gt;&lt;span style=color:rgb(75,143,211)&gt;Path:&lt;/span&gt; &quot; + httpRequest.uri().getPath();</span>
<span class="fc bfc" id="L313" title="All 2 branches covered.">                if (httpRequest.uri().getQuery() != null) {</span>
<span class="fc" id="L314">                    report += &quot;&lt;br&gt;&lt;span style=color:rgb(75,143,211)&gt;Query:&lt;/span&gt; &quot; + httpRequest.uri().getQuery();</span>
                }

<span class="fc" id="L317">                if (</span>
<span class="fc bfc" id="L318" title="All 2 branches covered.">                    !(this.mediatorUtils.getParameterUtil().getListRequest().isEmpty()</span>
<span class="fc bfc" id="L319" title="All 2 branches covered.">                    &amp;&amp; this.mediatorUtils.getCsrfUtil().getTokenCsrf() == null)</span>
                ) {
<span class="fc" id="L321">                    report += &quot;&lt;br&gt;&lt;span style=color:rgb(75,143,211)&gt;Body:&lt;/span&gt; &quot; + body;</span>
                }

<span class="fc" id="L324">                report += &quot;&lt;br&gt;&lt;span style=color:rgb(75,143,211)&gt;Header:&lt;/span&gt; &quot; + httpRequest.headers().map().entrySet().stream()</span>
<span class="fc" id="L325">                    .map(entry -&gt; String.format(&quot;%s: %s&quot;, entry.getKey(), String.join(&quot;&quot;, entry.getValue())))</span>
<span class="fc" id="L326">                    .collect(Collectors.joining(&quot;&lt;br&gt;&quot;));</span>
<span class="fc" id="L327">                return report;</span>
            }
            
<span class="fc" id="L330">            HttpResponse&lt;String&gt; response = this.getMediatorUtils().getConnectionUtil().getHttpClient().send(</span>
<span class="fc" id="L331">                httpRequestBuilder.build(),</span>
<span class="fc" id="L332">                BodyHandlers.ofString()</span>
            );

<span class="fc bfc" id="L335" title="All 2 branches covered.">            if (this.mediatorUtils.getParameterUtil().isRequestSoap()) {</span>
                // Invalid XML control chars like \x04 requires urlencoding from server
<span class="fc" id="L337">                pageSource = URLDecoder.decode(response.body(), StandardCharsets.UTF_8);</span>
            } else {
<span class="fc" id="L339">                pageSource = response.body();</span>
            }

<span class="fc" id="L342">            Map&lt;String, String&gt; headersResponse = ConnectionUtil.getHeadersMap(response);</span>
            
<span class="fc" id="L344">            msgHeader.put(Header.RESPONSE, headersResponse);</span>
<span class="fc" id="L345">            msgHeader.put(Header.HEADER, ConnectionUtil.getHeadersMap(httpRequest.headers()));</span>
            
<span class="fc" id="L347">            int sizeHeaders = headersResponse.keySet()</span>
<span class="fc" id="L348">                .stream()</span>
<span class="fc" id="L349">                .map(key -&gt; headersResponse.get(key).length() + key.length())</span>
<span class="fc" id="L350">                .mapToInt(Integer::intValue)</span>
<span class="fc" id="L351">                .sum();</span>
            
<span class="fc" id="L353">            float size = (float) (pageSource.length() + sizeHeaders) / 1024;</span>
<span class="fc" id="L354">            var decimalFormat = new DecimalFormat(&quot;0.000&quot;);</span>
<span class="fc" id="L355">            msgHeader.put(Header.PAGE_SIZE, decimalFormat.format(size));</span>
            
<span class="fc bfc" id="L357" title="All 2 branches covered.">            if (this.mediatorUtils.getParameterUtil().isRequestSoap()) {</span>
<span class="fc" id="L358">                pageSource = StringUtil.fromHtml(pageSource);</span>
            }
            
<span class="fc" id="L361">            msgHeader.put(</span>
                Header.SOURCE,
                pageSource
<span class="fc" id="L364">                .replaceAll(&quot;(#){60,}&quot;, &quot;$1...&quot;)  // Remove ranges of # created by calibration</span>
<span class="fc" id="L365">                .replaceAll(&quot;(jIyM){60,}&quot;, &quot;$1...&quot;)  // Remove batch of chars created by Dios</span>
            );
<span class="fc" id="L367">            msgHeader.put(Header.METADATA_PROCESS, metadataInjectionProcess);</span>
<span class="fc" id="L368">            msgHeader.put(Header.METADATA_STRATEGY, this.mediatorStrategy.getMeta());</span>
<span class="fc" id="L369">            msgHeader.put(Header.METADATA_BOOLEAN, callableBoolean);</span>
            
            // Send data to Views
<span class="fc" id="L372">            var request = new Request();</span>
<span class="fc" id="L373">            request.setMessage(Interaction.MESSAGE_HEADER);</span>
<span class="fc" id="L374">            request.setParameters(msgHeader);</span>
<span class="fc" id="L375">            this.sendToViews(request);</span>
            
<span class="nc" id="L377">        } catch (IOException e) {</span>
<span class="nc" id="L378">            LOGGER.log(</span>
                LogLevelUtil.CONSOLE_ERROR,
<span class="nc" id="L380">                String.format(&quot;Error during connection: %s&quot;, e.getMessage())</span>
            );
<span class="fc" id="L382">        } catch (InterruptedException e) {</span>
            
<span class="fc" id="L384">            LOGGER.log(LogLevelUtil.IGNORE, e, e);</span>
<span class="fc" id="L385">            Thread.currentThread().interrupt();</span>
<span class="pc" id="L386">        }</span>

        // return the source code of the page
<span class="fc" id="L389">        return pageSource;</span>
    }

    private URL initializeQueryString(
        boolean isUsingIndex,
        String urlInjection,
        String dataInjection,
        URL urlObject,
        Map&lt;Header, Object&gt; msgHeader
    ) {
        
<span class="fc" id="L400">        String urlInjectionFixed = urlInjection;</span>
<span class="fc" id="L401">        var urlObjectFixed = urlObject;</span>
        
<span class="fc" id="L403">        if (</span>
<span class="fc bfc" id="L404" title="All 2 branches covered.">            this.mediatorUtils.getParameterUtil().getListQueryString().isEmpty()</span>
<span class="pc bpc" id="L405" title="1 of 2 branches missed.">            &amp;&amp; !this.mediatorUtils.getPreferencesUtil().isProcessingCsrf()</span>
        ) {

<span class="fc" id="L408">            msgHeader.put(Header.URL, urlInjectionFixed);</span>
<span class="fc" id="L409">            return urlObjectFixed;</span>
        }
            
        // URL without query string like Request and Header can receive
        // new params from &lt;form&gt; parsing, in that case add the '?' to URL
<span class="pc bpc" id="L414" title="1 of 2 branches missed.">        if (!urlInjectionFixed.contains(&quot;?&quot;)) {</span>
<span class="nc" id="L415">            urlInjectionFixed += &quot;?&quot;;</span>
        }

<span class="fc" id="L418">        urlInjectionFixed += this.buildQuery(</span>
<span class="fc" id="L419">            this.mediatorMethod.getQuery(),</span>
<span class="fc" id="L420">            this.mediatorUtils.getParameterUtil().getQueryStringFromEntries(),</span>
            isUsingIndex,
            dataInjection
        );

<span class="fc" id="L425">        urlInjectionFixed = this.mediatorUtils.getCsrfUtil().addQueryStringToken(urlInjectionFixed);</span>
        
        // TODO Keep single check
        try {
<span class="fc" id="L429">            urlObjectFixed = new URI(urlInjectionFixed).toURL();</span>
<span class="nc" id="L430">        } catch (MalformedURLException | URISyntaxException e) {</span>
<span class="nc" id="L431">            LOGGER.log(</span>
                LogLevelUtil.CONSOLE_ERROR,
<span class="nc" id="L433">                String.format(&quot;Incorrect Url: %s&quot;, e.getMessage())</span>
            );
<span class="fc" id="L435">        }</span>

<span class="fc" id="L437">        msgHeader.put(Header.URL, urlInjectionFixed);</span>
        
<span class="fc" id="L439">        return urlObjectFixed;</span>
    }

    private void initializeHeader(
        boolean isUsingIndex,
        String dataInjection,
        Builder httpRequest
    ) {
<span class="fc bfc" id="L447" title="All 2 branches covered.">        if (!this.mediatorUtils.getParameterUtil().getListHeader().isEmpty()) {</span>
<span class="fc" id="L448">            Stream.of(</span>
<span class="fc" id="L449">                this.buildQuery(</span>
<span class="fc" id="L450">                    this.mediatorMethod.getHeader(),</span>
<span class="fc" id="L451">                    this.mediatorUtils.getParameterUtil().getHeaderFromEntries(),</span>
                    isUsingIndex,
                    dataInjection
                )
<span class="fc" id="L455">                .split(&quot;\\\\r\\\\n&quot;)</span>
            )
<span class="fc" id="L457">            .forEach(header -&gt; {</span>
<span class="fc bfc" id="L458" title="All 2 branches covered.">                if (header.split(&quot;:&quot;).length == 2) {</span>
                    try {  // TODO Should not catch, rethrow or use runtime exception
<span class="fc" id="L460">                        HeaderUtil.sanitizeHeaders(</span>
                            httpRequest,
                            new SimpleEntry&lt;&gt;(
<span class="fc" id="L463">                                header.split(&quot;:&quot;)[0],</span>
<span class="fc" id="L464">                                header.split(&quot;:&quot;)[1]</span>
                            )
                        );
<span class="nc" id="L467">                    } catch (JSqlException e) {</span>
<span class="nc" id="L468">                        LOGGER.log(LogLevelUtil.CONSOLE_ERROR, &quot;Headers sanitizing issue caught already during connection, ignoring&quot;, e);</span>
<span class="fc" id="L469">                    }</span>
                }
<span class="fc" id="L471">            });</span>
        }
<span class="fc" id="L473">    }</span>

    private String initializeRequest(
        boolean isUsingIndex,
        String dataInjection,
        Builder httpRequest,
        Map&lt;Header, Object&gt; msgHeader
    ) {
        
<span class="fc" id="L482">        if (</span>
<span class="fc bfc" id="L483" title="All 2 branches covered.">            this.mediatorUtils.getParameterUtil().getListRequest().isEmpty()</span>
<span class="fc bfc" id="L484" title="All 2 branches covered.">            &amp;&amp; this.mediatorUtils.getCsrfUtil().getTokenCsrf() == null</span>
        ) {
<span class="fc" id="L486">            return dataInjection;</span>
        }
            
        // Set connection method
        // Active for query string injection too, in that case inject query string still with altered method
        
<span class="fc" id="L492">        var body = new StringBuilder();</span>
        
<span class="fc bfc" id="L494" title="All 2 branches covered.">        if (this.mediatorUtils.getParameterUtil().isRequestSoap()) {</span>
<span class="fc" id="L495">            httpRequest.setHeader(HeaderUtil.CONTENT_TYPE_REQUEST, &quot;text/xml&quot;);</span>
        } else {
<span class="fc" id="L497">            httpRequest.setHeader(HeaderUtil.CONTENT_TYPE_REQUEST, &quot;application/x-www-form-urlencoded&quot;);</span>
        }
   
<span class="fc" id="L500">        this.mediatorUtils.getCsrfUtil().addRequestToken(body);</span>
            
<span class="fc bfc" id="L502" title="All 2 branches covered.">        if (this.mediatorUtils.getConnectionUtil().getTypeRequest().matches(&quot;PUT|POST&quot;)) {</span>
<span class="fc bfc" id="L503" title="All 2 branches covered.">            if (this.mediatorUtils.getParameterUtil().isRequestSoap()) {</span>
<span class="fc" id="L504">                body.append(</span>
<span class="fc" id="L505">                    this.buildQuery(</span>
<span class="fc" id="L506">                        this.mediatorMethod.getRequest(),</span>
<span class="fc" id="L507">                        this.mediatorUtils.getParameterUtil().getRawRequest(),</span>
                        isUsingIndex,
                        dataInjection
                    )
                    // Invalid XML characters in recent Spring version
                    // Server needs to urldecode, or stop using out of range chars
<span class="fc" id="L513">                    .replace(&quot;\u0001&quot;, &quot;&amp;#01;&quot;)</span>
<span class="fc" id="L514">                    .replace(&quot;\u0003&quot;, &quot;&amp;#03;&quot;)</span>
<span class="fc" id="L515">                    .replace(&quot;\u0004&quot;, &quot;&amp;#04;&quot;)</span>
<span class="fc" id="L516">                    .replace(&quot;\u0005&quot;, &quot;&amp;#05;&quot;)</span>
<span class="fc" id="L517">                    .replace(&quot;\u0006&quot;, &quot;&amp;#06;&quot;)</span>
<span class="fc" id="L518">                    .replace(&quot;\u0007&quot;, &quot;&amp;#07;&quot;)</span>
<span class="fc" id="L519">                    .replace(&quot;+&quot;, &quot;%2B&quot;)  // Prevent replace '+' into 'space' on server side urldecode</span>
                );
            } else {
<span class="fc" id="L522">                body.append(</span>
<span class="fc" id="L523">                    this.buildQuery(</span>
<span class="fc" id="L524">                        this.mediatorMethod.getRequest(),</span>
<span class="fc" id="L525">                        this.mediatorUtils.getParameterUtil().getRequestFromEntries(),</span>
                        isUsingIndex,
                        dataInjection
                    )
                );
            }
        }
        
<span class="fc" id="L533">        var bodyPublisher = BodyPublishers.ofString(body.toString());</span>
        
<span class="fc" id="L535">        httpRequest.method(</span>
<span class="fc" id="L536">            this.mediatorUtils.getConnectionUtil().getTypeRequest(),</span>
            bodyPublisher
        );
        
<span class="fc" id="L540">        msgHeader.put(Header.POST, body.toString());</span>
<span class="fc" id="L541">        return body.toString();</span>
    }
    
    private String buildQuery(AbstractMethodInjection methodInjection, String paramLead, boolean isUsingIndex, String sqlTrail) {
        
        String query;
<span class="fc" id="L547">        String paramLeadFixed = paramLead.replace(</span>
            InjectionModel.STAR,
            TamperingUtil.TAG_OPENED + InjectionModel.STAR + TamperingUtil.TAG_CLOSED
        );
        
<span class="fc" id="L552">        if (</span>
            // No parameter transformation if method is not selected by user
<span class="fc bfc" id="L554" title="All 2 branches covered.">            this.mediatorUtils.getConnectionUtil().getMethodInjection() != methodInjection</span>
            // No parameter transformation if injection point in URL
<span class="fc bfc" id="L556" title="All 2 branches covered.">            || this.mediatorUtils.getConnectionUtil().getUrlBase().contains(InjectionModel.STAR)</span>
        ) {
            // Just pass parameters without any transformation
<span class="fc" id="L559">            query = paramLeadFixed;</span>
<span class="fc" id="L560">        } else if (</span>
            // If method is selected by user and URL does not contain injection point
            // but parameters contain an injection point
            // then replace injection point by SQL expression in this parameter
<span class="fc bfc" id="L564" title="All 2 branches covered.">            paramLeadFixed.contains(InjectionModel.STAR)</span>
        ) {
<span class="fc" id="L566">            query = this.initializeStarInjection(paramLeadFixed, isUsingIndex, sqlTrail);</span>
        } else {
<span class="fc" id="L568">            query = this.initializeRawInjection(paramLeadFixed, isUsingIndex, sqlTrail);</span>
        }
        
        // Remove comments except empty /**/
<span class="fc" id="L572">        query = this.cleanQuery(methodInjection, query);</span>
        
        // Add empty comments with space=&gt;/**/
<span class="fc bfc" id="L575" title="All 2 branches covered.">        if (this.mediatorUtils.getConnectionUtil().getMethodInjection() == methodInjection) {</span>
<span class="fc" id="L576">            query = this.mediatorUtils.getTamperingUtil().tamper(query);</span>
        }
        
<span class="fc" id="L579">        query = this.applyEncoding(methodInjection, query);</span>
        
<span class="fc" id="L581">        return query;</span>
    }

    private String initializeRawInjection(String paramLead, boolean isUsingIndex, String sqlTrail) {
        
        String query;
        
        // Method is selected by user and there's no injection point
<span class="pc bpc" id="L589" title="1 of 2 branches missed.">        if (!isUsingIndex) {</span>
            // Several SQL expressions does not use indexes in SELECT,
            // like Boolean, Error, Shell and search for character insertion,
            // in that case concat SQL expression to the end of param.
<span class="fc" id="L593">            query = paramLead + sqlTrail;</span>
        } else {
            // Concat indexes found for Normal strategy to params
            // and use visible Index for injection
<span class="nc" id="L597">            query = paramLead + this.indexesInUrl.replaceAll(</span>
<span class="nc" id="L598">                String.format(VendorYaml.FORMAT_INDEX, this.mediatorStrategy.getNormal().getVisibleIndex()),</span>
                // Oracle column often contains $, which is reserved for regex.
                // =&gt; need to be escape with quoteReplacement()
<span class="nc" id="L601">                Matcher.quoteReplacement(sqlTrail)</span>
            );
        }

        // Add ending line comment by vendor
<span class="fc" id="L606">        query = query + this.mediatorVendor.getVendor().instance().endingComment();</span>

<span class="fc" id="L608">        return query;</span>
    }

    private String initializeStarInjection(String paramLead, boolean isUsingIndex, String sqlTrail) {
        
        String query;
        
        // Several SQL expressions does not use indexes in SELECT,
        // like Boolean, Error, Shell and search for character insertion,
        // in that case replace injection point by SQL expression.
        // Injection point is always at the end?
<span class="fc bfc" id="L619" title="All 2 branches covered.">        if (!isUsingIndex) {</span>
<span class="fc" id="L620">            query = paramLead.replace(</span>
                InjectionModel.STAR,
<span class="fc" id="L622">                sqlTrail + this.mediatorVendor.getVendor().instance().endingComment()</span>
            );
        } else {
            // Replace injection point by indexes found for Normal strategy
            // and use visible Index for injection
<span class="fc" id="L627">            query = paramLead.replace(</span>
                InjectionModel.STAR,
<span class="fc" id="L629">                this.indexesInUrl.replace(</span>
<span class="fc" id="L630">                    String.format(VendorYaml.FORMAT_INDEX, this.mediatorStrategy.getNormal().getVisibleIndex()),</span>
                    sqlTrail
                )
<span class="fc" id="L633">                + this.mediatorVendor.getVendor().instance().endingComment()</span>
            );
        }
        
<span class="fc" id="L637">        return query;</span>
    }

    /**
     * Dependency:
     * - Tamper space=&gt;comment
     * @param methodInjection
     * @param query
     * @return
     */
    private String cleanQuery(AbstractMethodInjection methodInjection, String query) {
        
<span class="fc" id="L649">        String queryFixed = query;</span>
        
<span class="fc" id="L651">        if (</span>
<span class="fc bfc" id="L652" title="All 2 branches covered.">            methodInjection == this.mediatorMethod.getRequest()</span>
            &amp;&amp; (
<span class="fc bfc" id="L654" title="All 2 branches covered.">                this.mediatorUtils.getParameterUtil().isRequestSoap()</span>
<span class="fc bfc" id="L655" title="All 2 branches covered.">                || this.mediatorUtils.getParameterUtil().isMultipartRequest()</span>
            )
        ) {
<span class="fc" id="L658">            queryFixed = StringUtil.removeSqlComment(queryFixed)</span>
<span class="fc" id="L659">                .replace(&quot;+&quot;, &quot; &quot;)</span>
<span class="fc" id="L660">                .replace(&quot;%2b&quot;, &quot;+&quot;)  // Failsafe</span>
<span class="fc" id="L661">                .replace(&quot;%23&quot;, &quot;#&quot;);  // End comment</span>

<span class="fc bfc" id="L663" title="All 2 branches covered.">            if (this.mediatorUtils.getParameterUtil().isMultipartRequest()) {</span>
                // restore linefeed from textfield
<span class="fc" id="L665">                queryFixed = queryFixed.replaceAll(&quot;(?s)\\\\n&quot;, &quot;\r\n&quot;);</span>
            }
        } else {
<span class="fc" id="L668">            queryFixed = StringUtil.cleanSql(queryFixed);</span>
        }
        
<span class="fc" id="L671">        return queryFixed;</span>
    }

    private String applyEncoding(AbstractMethodInjection methodInjection, String query) {
        
<span class="fc" id="L676">        String queryFixed = query;</span>
        
<span class="fc bfc" id="L678" title="All 2 branches covered.">        if (!this.mediatorUtils.getParameterUtil().isRequestSoap()) {</span>
<span class="fc bfc" id="L679" title="All 2 branches covered.">            if (methodInjection == this.mediatorMethod.getQuery()) {</span>
                
                // URL encode each character because no query parameter context
<span class="pc bpc" id="L682" title="1 of 2 branches missed.">                if (!this.mediatorUtils.getPreferencesUtil().isUrlEncodingDisabled()) {</span>

<span class="fc" id="L684">                    queryFixed = queryFixed.replace(&quot;'&quot;, &quot;%27&quot;);</span>
<span class="fc" id="L685">                    queryFixed = queryFixed.replace(&quot;(&quot;, &quot;%28&quot;);</span>
<span class="fc" id="L686">                    queryFixed = queryFixed.replace(&quot;)&quot;, &quot;%29&quot;);</span>
<span class="fc" id="L687">                    queryFixed = queryFixed.replace(&quot;{&quot;, &quot;%7b&quot;);</span>
<span class="fc" id="L688">                    queryFixed = queryFixed.replace(&quot;[&quot;, &quot;%5b&quot;);</span>
<span class="fc" id="L689">                    queryFixed = queryFixed.replace(&quot;]&quot;, &quot;%5d&quot;);</span>
<span class="fc" id="L690">                    queryFixed = queryFixed.replace(&quot;}&quot;, &quot;%7d&quot;);</span>
<span class="fc" id="L691">                    queryFixed = queryFixed.replace(&quot;&gt;&quot;, &quot;%3e&quot;);</span>
<span class="fc" id="L692">                    queryFixed = queryFixed.replace(&quot;&lt;&quot;, &quot;%3c&quot;);</span>
<span class="fc" id="L693">                    queryFixed = queryFixed.replace(&quot;?&quot;, &quot;%3f&quot;);</span>
<span class="fc" id="L694">                    queryFixed = queryFixed.replace(&quot;_&quot;, &quot;%5f&quot;);</span>
<span class="fc" id="L695">                    queryFixed = queryFixed.replace(&quot;,&quot;, &quot;%2c&quot;);</span>
                }

                // HTTP forbidden characters
<span class="fc" id="L699">                queryFixed = queryFixed.replace(StringUtils.SPACE, &quot;+&quot;);</span>
<span class="fc" id="L700">                queryFixed = queryFixed.replace(&quot;`&quot;, &quot;%60&quot;);  // from `${database}`.`${table}`</span>
<span class="fc" id="L701">                queryFixed = queryFixed.replace(&quot;\&quot;&quot;, &quot;%22&quot;);</span>
<span class="fc" id="L702">                queryFixed = queryFixed.replace(&quot;|&quot;, &quot;%7c&quot;);</span>
<span class="fc" id="L703">                queryFixed = queryFixed.replace(&quot;\\&quot;, &quot;%5c&quot;);</span>
                
<span class="fc bfc" id="L705" title="All 2 branches covered.">            } else if (methodInjection != this.mediatorMethod.getRequest()) {</span>
                
                // For cookies in Spring (confirmed, covered by integration tests)
<span class="fc" id="L708">                queryFixed = queryFixed.replace(&quot;+&quot;, &quot;%20&quot;);</span>
<span class="fc" id="L709">                queryFixed = queryFixed.replace(&quot;,&quot;, &quot;%2c&quot;);</span>
<span class="fc" id="L710">                queryFixed = URLDecoder.decode(queryFixed, StandardCharsets.UTF_8);</span>
            }
        }
        
<span class="fc" id="L714">        return queryFixed;</span>
    }
    
    /**
     * Display source code in console.
     * @param message Error message
     * @param source Text to display in console
     */
    public void sendResponseFromSite(String message, String source) {
        
<span class="nc" id="L724">        LOGGER.log(LogLevelUtil.CONSOLE_ERROR, &quot;{}, response from site:&quot;, message);</span>
<span class="nc" id="L725">        LOGGER.log(LogLevelUtil.CONSOLE_ERROR, &quot;&gt;&gt;&gt;{}&quot;, source);</span>
<span class="nc" id="L726">    }</span>
    
    public void displayVersion() {
<span class="nc" id="L729">        LOGGER.log(</span>
            LogLevelUtil.CONSOLE_DEFAULT,
            &quot;jSQL Injection v{} on Java {}-{}-{}&quot;,
            this::getVersionJsql,
<span class="nc" id="L733">            () -&gt; SystemUtils.JAVA_VERSION,</span>
<span class="nc" id="L734">            () -&gt; SystemUtils.OS_ARCH,</span>
<span class="nc" id="L735">            () -&gt; SystemUtils.USER_LANGUAGE</span>
        );
<span class="nc" id="L737">    }</span>
    
    
    // Getters and setters

    public String getIndexesInUrl() {
<span class="fc" id="L743">        return this.indexesInUrl;</span>
    }

    public void setIndexesInUrl(String indexesInUrl) {
<span class="fc" id="L747">        this.indexesInUrl = indexesInUrl;</span>
<span class="fc" id="L748">    }</span>

    public boolean shouldErasePreviousInjection() {
<span class="nc" id="L751">        return this.shouldErasePreviousInjection;</span>
    }

    public void setIsScanning(boolean isScanning) {
<span class="fc" id="L755">        this.isScanning = isScanning;</span>
<span class="fc" id="L756">    }</span>

    public String getVersionJsql() {
<span class="fc" id="L759">        return this.propertiesUtil.getProperties().getProperty(&quot;jsql.version&quot;);</span>
    }

    public MediatorUtils getMediatorUtils() {
<span class="fc" id="L763">        return this.mediatorUtils;</span>
    }

    public MediatorVendor getMediatorVendor() {
<span class="fc" id="L767">        return this.mediatorVendor;</span>
    }

    public MediatorMethod getMediatorMethod() {
<span class="fc" id="L771">        return this.mediatorMethod;</span>
    }

    public DataAccess getDataAccess() {
<span class="fc" id="L775">        return this.dataAccess;</span>
    }

    public ResourceAccess getResourceAccess() {
<span class="fc" id="L779">        return this.resourceAccess;</span>
    }

    public MediatorStrategy getMediatorStrategy() {
<span class="fc" id="L783">        return this.mediatorStrategy;</span>
    }

    public void appendAnalysisReport(String analysisReport) {
<span class="fc" id="L787">        this.appendAnalysisReport(analysisReport, false);</span>
<span class="fc" id="L788">    }</span>

    public void appendAnalysisReport(String analysisReport, boolean isInit) {
<span class="fc bfc" id="L791" title="All 2 branches covered.">        this.analysisReport += (isInit ? StringUtils.EMPTY : &quot;&lt;br&gt;&lt;br&gt;&quot;) + analysisReport;</span>
<span class="fc" id="L792">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>