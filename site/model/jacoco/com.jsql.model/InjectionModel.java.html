<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>InjectionModel.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">model</a> &gt; <a href="index.source.html" class="el_package">com.jsql.model</a> &gt; <span class="el_source">InjectionModel.java</span></div><h1>InjectionModel.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyhacked (H) 2012-2020.
 * This program and the accompanying materials
 * are made available under no term at all, use it like
 * you want, but share and discuss about it
 * every time possible with every body.
 * 
 * Contributors:
 *      ron190 at ymail dot com - initial implementation
 ******************************************************************************/
package com.jsql.model;

import com.jsql.model.accessible.DataAccess;
import com.jsql.model.accessible.ResourceAccess;
import com.jsql.model.bean.util.Header;
import com.jsql.model.bean.util.Interaction;
import com.jsql.model.bean.util.Request;
import com.jsql.model.exception.JSqlException;
import com.jsql.model.injection.method.AbstractMethodInjection;
import com.jsql.model.injection.method.MediatorMethod;
import com.jsql.model.injection.strategy.MediatorStrategy;
import com.jsql.model.injection.strategy.blind.AbstractCallableBoolean;
import com.jsql.model.injection.vendor.MediatorVendor;
import com.jsql.model.injection.vendor.model.VendorYaml;
import com.jsql.util.*;
import com.jsql.util.GitUtil.ShowOnConsole;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.SystemUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.io.Serializable;
import java.net.*;
import java.net.http.HttpRequest;
import java.net.http.HttpRequest.BodyPublishers;
import java.net.http.HttpRequest.Builder;
import java.net.http.HttpResponse;
import java.net.http.HttpResponse.BodyHandlers;
import java.nio.charset.StandardCharsets;
import java.text.DecimalFormat;
import java.time.Duration;
import java.util.AbstractMap.SimpleEntry;
import java.util.EnumMap;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.stream.Stream;

/**
 * Model class of MVC pattern for processing SQL injection automatically.&lt;br&gt;
 * Different views can be attached to this observable, like Swing or command line, in order to separate
 * the functional job from the graphical processing.&lt;br&gt;
 * The Model has a specific database vendor and strategy which run an automatic injection to get name of
 * databases, tables, columns and values, and it can also retrieve resources like files and shell.&lt;br&gt;
 * Tasks are run in multi-threads in general to speed the process.
 */
public class InjectionModel extends AbstractModelObservable implements Serializable {
    
    /**
     * Log4j logger sent to view.
     */
<span class="fc" id="L62">    private static final Logger LOGGER = LogManager.getRootLogger();</span>
    
<span class="fc" id="L64">    private final transient MediatorVendor mediatorVendor = new MediatorVendor(this);</span>
<span class="fc" id="L65">    private final transient MediatorMethod mediatorMethod = new MediatorMethod(this);</span>
    private final transient MediatorUtils mediatorUtils;
    private final transient MediatorStrategy mediatorStrategy;

<span class="fc" id="L69">    private final transient PropertiesUtil propertiesUtil = new PropertiesUtil();</span>
             
<span class="fc" id="L71">    private final transient DataAccess dataAccess = new DataAccess(this);</span>
<span class="fc" id="L72">    private final transient ResourceAccess resourceAccess = new ResourceAccess(this);</span>
    
    public static final String STAR = &quot;*&quot;;
    
    /**
     * initialUrl transformed to a correct injection url.
     */
<span class="fc" id="L79">    private String indexesInUrl = StringUtils.EMPTY;</span>
    
    /**
     * Allow to directly start an injection after a failed one
     * without asking the user 'Start a new injection?'.
     */
<span class="fc" id="L85">    private boolean shouldErasePreviousInjection = false;</span>
    
<span class="fc" id="L87">    private boolean isScanning = false;</span>
    
<span class="fc" id="L89">    public InjectionModel() {</span>
        
<span class="fc" id="L91">        this.mediatorUtils = new MediatorUtils();</span>
        
<span class="fc" id="L93">        this.mediatorStrategy = new MediatorStrategy(this);</span>

<span class="fc" id="L95">        this.mediatorUtils.setCertificateUtil(new CertificateUtil());</span>
<span class="fc" id="L96">        this.mediatorUtils.setPropertiesUtil(this.propertiesUtil);</span>
<span class="fc" id="L97">        this.mediatorUtils.setConnectionUtil(new ConnectionUtil(this));</span>
<span class="fc" id="L98">        this.mediatorUtils.setAuthenticationUtil(new AuthenticationUtil());</span>
<span class="fc" id="L99">        this.mediatorUtils.setGitUtil(new GitUtil(this));</span>
<span class="fc" id="L100">        this.mediatorUtils.setHeaderUtil(new HeaderUtil(this));</span>
<span class="fc" id="L101">        this.mediatorUtils.setParameterUtil(new ParameterUtil(this));</span>
<span class="fc" id="L102">        this.mediatorUtils.setExceptionUtil(new ExceptionUtil(this));</span>
<span class="fc" id="L103">        this.mediatorUtils.setSoapUtil(new SoapUtil(this));</span>
<span class="fc" id="L104">        this.mediatorUtils.setMultipartUtil(new MultipartUtil(this));</span>
<span class="fc" id="L105">        this.mediatorUtils.setCookiesUtil(new CookiesUtil(this));</span>
<span class="fc" id="L106">        this.mediatorUtils.setJsonUtil(new JsonUtil(this));</span>
<span class="fc" id="L107">        this.mediatorUtils.setPreferencesUtil(new PreferencesUtil());</span>
<span class="fc" id="L108">        this.mediatorUtils.setProxyUtil(new ProxyUtil(this));</span>
<span class="fc" id="L109">        this.mediatorUtils.setThreadUtil(new ThreadUtil(this));</span>
<span class="fc" id="L110">        this.mediatorUtils.setTamperingUtil(new TamperingUtil());</span>
<span class="fc" id="L111">        this.mediatorUtils.setUserAgentUtil(new UserAgentUtil());</span>
<span class="fc" id="L112">        this.mediatorUtils.setCsrfUtil(new CsrfUtil(this));</span>
<span class="fc" id="L113">        this.mediatorUtils.setFormUtil(new FormUtil(this));</span>
<span class="fc" id="L114">        this.mediatorUtils.setDigestUtil(new DigestUtil(this));</span>
<span class="fc" id="L115">    }</span>

    /**
     * Reset each injection attributes: Database metadata, General Thread status, Strategy.
     */
    public void resetModel() {
        
<span class="fc" id="L122">        this.mediatorStrategy.getNormal().setVisibleIndex(null);</span>
        
<span class="fc" id="L124">        this.mediatorStrategy.getNormal().setApplicable(false);</span>
<span class="fc" id="L125">        this.mediatorStrategy.getError().setApplicable(false);</span>
<span class="fc" id="L126">        this.mediatorStrategy.getBlind().setApplicable(false);</span>
<span class="fc" id="L127">        this.mediatorStrategy.getMultibit().setApplicable(false);</span>
<span class="fc" id="L128">        this.mediatorStrategy.getTime().setApplicable(false);</span>
<span class="fc" id="L129">        this.mediatorStrategy.getStacked().setApplicable(false);</span>

<span class="fc" id="L131">        this.indexesInUrl = StringUtils.EMPTY;</span>
        
<span class="fc" id="L133">        this.mediatorUtils.getCsrfUtil().setTokenCsrf(null);</span>
<span class="fc" id="L134">        this.mediatorUtils.getDigestUtil().setTokenDigest(null);</span>

<span class="fc" id="L136">        this.setIsStoppedByUser(false);</span>
        
<span class="fc" id="L138">        this.shouldErasePreviousInjection = false;</span>
        
<span class="fc" id="L140">        this.mediatorStrategy.setStrategy(null);</span>
        
<span class="fc" id="L142">        this.resourceAccess.setReadingIsAllowed(false);</span>
        
<span class="fc" id="L144">        this.mediatorUtils.getThreadUtil().reset();</span>
<span class="fc" id="L145">    }</span>

    /**
     * Prepare the injection process, can be interrupted by the user (via shouldStopAll).
     * Erase all attributes eventually defined in a previous injection.
     * Run by Scan, Standard and TU.
     */
    public void beginInjection() {
        
<span class="fc" id="L154">        this.resetModel();</span>
        
        try {
<span class="pc bpc" id="L157" title="1 of 2 branches missed.">            if (!this.mediatorUtils.getProxyUtil().isLive(ShowOnConsole.YES)) {</span>
                
<span class="nc" id="L159">                return;</span>
            }
            
<span class="fc" id="L162">            LOGGER.log(</span>
                LogLevelUtil.CONSOLE_INFORM,
                &quot;{}: {}&quot;,
<span class="fc" id="L165">                () -&gt; I18nUtil.valueByKey(&quot;LOG_START_INJECTION&quot;),</span>
<span class="fc" id="L166">                () -&gt; this.mediatorUtils.getConnectionUtil().getUrlByUser()</span>
            );
            
            // Check general integrity if user's parameters
<span class="fc" id="L170">            this.mediatorUtils.getParameterUtil().checkParametersFormat();</span>
            
<span class="fc" id="L172">            this.mediatorUtils.getConnectionUtil().testConnection();</span>

            // TODO Check all path params
<span class="fc" id="L175">            boolean hasFoundInjection = this.mediatorMethod.getQuery().testParameters(false);</span>
<span class="fc" id="L176">            hasFoundInjection = this.mediatorUtils.getMultipartUtil().testParameters(hasFoundInjection);</span>
<span class="fc" id="L177">            hasFoundInjection = this.mediatorUtils.getSoapUtil().testParameters(hasFoundInjection);</span>
<span class="fc" id="L178">            hasFoundInjection = this.mediatorMethod.getRequest().testParameters(hasFoundInjection);</span>
<span class="fc" id="L179">            hasFoundInjection = this.mediatorMethod.getHeader().testParameters(hasFoundInjection);</span>
<span class="fc" id="L180">            hasFoundInjection = this.mediatorUtils.getCookiesUtil().testParameters(hasFoundInjection);</span>

<span class="fc bfc" id="L182" title="All 4 branches covered.">            if (hasFoundInjection &amp;&amp; !this.isScanning) {</span>
                
<span class="fc bfc" id="L184" title="All 2 branches covered.">                if (this.getMediatorUtils().getPreferencesUtil().isZipStrategy()) {</span>
                    
<span class="fc" id="L186">                    LOGGER.log(LogLevelUtil.CONSOLE_INFORM, &quot;Using Zip mode for reduced query size&quot;);</span>
                    
<span class="fc bfc" id="L188" title="All 2 branches covered.">                } else if (this.getMediatorUtils().getPreferencesUtil().isDiosStrategy()) {</span>
                    
<span class="fc" id="L190">                    LOGGER.log(LogLevelUtil.CONSOLE_INFORM, &quot;Using Dump In One Shot strategy for single query dump&quot;);</span>
                }
                
<span class="pc bpc" id="L193" title="1 of 2 branches missed.">                if (!this.mediatorUtils.getPreferencesUtil().isNotInjectingMetadata()) {</span>
                    
<span class="fc" id="L195">                    this.dataAccess.getDatabaseInfos();</span>
                }
                
<span class="fc" id="L198">                this.dataAccess.listDatabases();</span>
            }
            
<span class="fc" id="L201">            LOGGER.log(LogLevelUtil.CONSOLE_DEFAULT, () -&gt; I18nUtil.valueByKey(&quot;LOG_DONE&quot;));</span>
            
<span class="fc" id="L203">            this.shouldErasePreviousInjection = true;</span>
            
<span class="nc" id="L205">        } catch (InterruptedException e) {</span>
            
<span class="nc" id="L207">            LOGGER.log(LogLevelUtil.IGNORE, e, e);</span>
<span class="nc" id="L208">            Thread.currentThread().interrupt();</span>
            
<span class="nc" id="L210">        } catch (JSqlException | IOException e) {  // Catch expected exceptions only</span>

<span class="nc bnc" id="L212" title="All 2 branches missed.">            if (e.getMessage() == null) {</span>
<span class="nc" id="L213">                LOGGER.log(LogLevelUtil.CONSOLE_ERROR, &quot;Unexpected: {}&quot;, getImplicitReason(e));</span>
            } else {
<span class="nc" id="L215">                LOGGER.log(LogLevelUtil.CONSOLE_ERROR, &quot;Unexpected: {}&quot;, e.getMessage());</span>
            }

<span class="nc bnc" id="L218" title="All 2 branches missed.">            if (e.toString().contains(&quot;HTTP/1.1&quot;)) {</span>

<span class="nc" id="L220">                LOGGER.log(LogLevelUtil.CONSOLE_ERROR, &quot;Something went wrong with HTTP/2, try to switch manually to HTTP/1.1 in preferences&quot;);</span>
            }
            
        } finally {
            
<span class="fc" id="L225">            var request = new Request();</span>
<span class="fc" id="L226">            request.setMessage(Interaction.END_PREPARATION);</span>
<span class="fc" id="L227">            this.sendToViews(request);</span>
        }
<span class="fc" id="L229">    }</span>
    
    public static String getImplicitReason(Throwable e) {
        
<span class="nc" id="L233">        String eMessage = e.getClass().getSimpleName();</span>
        
<span class="nc bnc" id="L235" title="All 2 branches missed.">        if (e.getMessage() != null) {</span>
            
<span class="nc" id="L237">            eMessage += &quot;: &quot;+ e.getMessage();</span>
        }
        
<span class="nc bnc" id="L240" title="All 4 branches missed.">        if (e.getCause() != null &amp;&amp; !e.equals(e.getCause())) {</span>
            
<span class="nc" id="L242">            eMessage += &quot; &gt; &quot;+ getImplicitReason(e.getCause());</span>
        }
        
<span class="nc" id="L245">        return eMessage;</span>
    }
    
    /**
     * Run a HTTP connection to the web server.
     * @param dataInjection SQL query
     * @return source code of current page
     */
    @Override
    public String inject(String dataInjection, boolean isUsingIndex, String metadataInjectionProcess, AbstractCallableBoolean&lt;?&gt; callableBoolean) {
        
        // Temporary url, we go from &quot;select 1,2,3,4...&quot; to &quot;select 1,([complex query]),2...&quot;, but keep initial url
<span class="fc" id="L257">        String urlInjection = this.mediatorUtils.getConnectionUtil().getUrlBase();</span>

<span class="fc" id="L259">        urlInjection = this.mediatorStrategy.buildPath(urlInjection, isUsingIndex, dataInjection);</span>
        
<span class="fc" id="L261">        urlInjection = StringUtil.cleanSql(urlInjection.trim());</span>

        URL urlObject;
        
        // TODO Keep only a single check
        try {
<span class="fc" id="L267">            urlObject = new URI(urlInjection).toURL();</span>
            
<span class="nc" id="L269">        } catch (MalformedURLException | URISyntaxException e) {</span>
            
<span class="nc" id="L271">            LOGGER.log(</span>
                LogLevelUtil.CONSOLE_ERROR,
<span class="nc" id="L273">                String.format(&quot;Incorrect Query Url: %s&quot;, e.getMessage())</span>
            );
<span class="nc" id="L275">            return StringUtils.EMPTY;</span>
<span class="fc" id="L276">        }</span>

<span class="fc" id="L278">        Map&lt;Header, Object&gt; msgHeader = new EnumMap&lt;&gt;(Header.class);</span>

        // TODO identique urlInjection == urlObject
<span class="fc" id="L281">        urlObject = this.initializeQueryString(</span>
            isUsingIndex,
            urlInjection,
            dataInjection,
            urlObject,
            msgHeader
        );
        
<span class="fc" id="L289">        String pageSource = StringUtils.EMPTY;</span>
        
        // Define the connection
        try {
<span class="fc" id="L293">            var httpRequestBuilder = HttpRequest.newBuilder()</span>
<span class="fc" id="L294">                .uri(URI.create(urlObject.toString()))</span>
<span class="fc" id="L295">                .setHeader(HeaderUtil.CONTENT_TYPE_REQUEST, &quot;text/plain&quot;)</span>
<span class="fc" id="L296">                .timeout(Duration.ofSeconds(15));</span>
            
<span class="fc" id="L298">            this.mediatorUtils.getCsrfUtil().addHeaderToken(httpRequestBuilder);</span>
<span class="fc" id="L299">            this.mediatorUtils.getDigestUtil().addHeaderToken(httpRequestBuilder);</span>

<span class="fc" id="L301">            this.mediatorUtils.getConnectionUtil().setCustomUserAgent(httpRequestBuilder);</span>
            
<span class="fc" id="L303">            this.initializeRequest(isUsingIndex, dataInjection, httpRequestBuilder, msgHeader);</span>
<span class="fc" id="L304">            this.initializeHeader(isUsingIndex, dataInjection, httpRequestBuilder);</span>
            
<span class="fc" id="L306">            var httpRequest = httpRequestBuilder.build();</span>
            
<span class="fc" id="L308">            HttpResponse&lt;String&gt; response = this.getMediatorUtils().getConnectionUtil().getHttpClient().send(</span>
<span class="fc" id="L309">                httpRequestBuilder.build(),</span>
<span class="fc" id="L310">                BodyHandlers.ofString()</span>
            );

<span class="fc bfc" id="L313" title="All 2 branches covered.">            if (this.mediatorUtils.getParameterUtil().isRequestSoap()) {</span>
                // Invalid XML control chars like \x04 requires urlencoding from server
<span class="fc" id="L315">                pageSource = URLDecoder.decode(response.body(), StandardCharsets.UTF_8);</span>
            } else {
<span class="fc" id="L317">                pageSource = response.body();</span>
            }

<span class="fc" id="L320">            Map&lt;String, String&gt; headersResponse = ConnectionUtil.getHeadersMap(response);</span>
            
<span class="fc" id="L322">            msgHeader.put(Header.RESPONSE, headersResponse);</span>
<span class="fc" id="L323">            msgHeader.put(Header.HEADER, ConnectionUtil.getHeadersMap(httpRequest.headers()));</span>
            
<span class="fc" id="L325">            int sizeHeaders = headersResponse.keySet()</span>
<span class="fc" id="L326">                .stream()</span>
<span class="fc" id="L327">                .map(key -&gt; headersResponse.get(key).length() + key.length())</span>
<span class="fc" id="L328">                .mapToInt(Integer::intValue)</span>
<span class="fc" id="L329">                .sum();</span>
            
<span class="fc" id="L331">            float size = (float) (pageSource.length() + sizeHeaders) / 1024;</span>
<span class="fc" id="L332">            var decimalFormat = new DecimalFormat(&quot;0.000&quot;);</span>
<span class="fc" id="L333">            msgHeader.put(Header.PAGE_SIZE, decimalFormat.format(size));</span>
            
<span class="fc bfc" id="L335" title="All 2 branches covered.">            if (this.mediatorUtils.getParameterUtil().isRequestSoap()) {</span>
                
<span class="fc" id="L337">                pageSource = StringUtil.fromHtml(pageSource);</span>
            }
            
<span class="fc" id="L340">            msgHeader.put(</span>
                Header.SOURCE,
                pageSource
<span class="fc" id="L343">                .replaceAll(&quot;(#){60,}&quot;, &quot;$1...&quot;)  // Remove ranges of # created by calibration</span>
<span class="fc" id="L344">                .replaceAll(&quot;(jIyM){60,}&quot;, &quot;$1...&quot;)  // Remove batch of chars created by Dios</span>
            );
<span class="fc" id="L346">            msgHeader.put(Header.METADATA_PROCESS, metadataInjectionProcess);</span>
<span class="fc" id="L347">            msgHeader.put(Header.METADATA_STRATEGY, this.mediatorStrategy.getMeta());</span>
<span class="fc" id="L348">            msgHeader.put(Header.METADATA_BOOLEAN, callableBoolean);</span>
            
            // Send data to Views
<span class="fc" id="L351">            var request = new Request();</span>
<span class="fc" id="L352">            request.setMessage(Interaction.MESSAGE_HEADER);</span>
<span class="fc" id="L353">            request.setParameters(msgHeader);</span>
<span class="fc" id="L354">            this.sendToViews(request);</span>
            
<span class="fc" id="L356">        } catch (IOException e) {</span>
            
<span class="fc" id="L358">            LOGGER.log(</span>
                LogLevelUtil.CONSOLE_ERROR,
<span class="fc" id="L360">                String.format(&quot;Error during connection: %s&quot;, e.getMessage())</span>
            );
            
<span class="fc" id="L363">        } catch (InterruptedException e) {</span>
            
<span class="fc" id="L365">            LOGGER.log(LogLevelUtil.IGNORE, e, e);</span>
<span class="fc" id="L366">            Thread.currentThread().interrupt();</span>
<span class="fc" id="L367">        }</span>

        // return the source code of the page
<span class="fc" id="L370">        return pageSource;</span>
    }

    private URL initializeQueryString(
        boolean isUsingIndex,
        String urlInjection,
        String dataInjection,
        URL urlObject,
        Map&lt;Header, Object&gt; msgHeader
    ) {
        
<span class="fc" id="L381">        String urlInjectionFixed = urlInjection;</span>
<span class="fc" id="L382">        var urlObjectFixed = urlObject;</span>
        
<span class="fc" id="L384">        if (</span>
<span class="fc bfc" id="L385" title="All 2 branches covered.">            this.mediatorUtils.getParameterUtil().getListQueryString().isEmpty()</span>
<span class="pc bpc" id="L386" title="1 of 2 branches missed.">            &amp;&amp; !this.mediatorUtils.getPreferencesUtil().isProcessingCsrf()</span>
        ) {

<span class="fc" id="L389">            msgHeader.put(Header.URL, urlInjectionFixed);</span>
<span class="fc" id="L390">            return urlObjectFixed;</span>
        }
            
        // URL without query string like Request and Header can receive
        // new params from &lt;form&gt; parsing, in that case add the '?' to URL
<span class="fc bfc" id="L395" title="All 2 branches covered.">        if (!urlInjectionFixed.contains(&quot;?&quot;)) {</span>
            
<span class="fc" id="L397">            urlInjectionFixed += &quot;?&quot;;</span>
        }

<span class="fc" id="L400">        urlInjectionFixed += this.buildQuery(</span>
<span class="fc" id="L401">            this.mediatorMethod.getQuery(),</span>
<span class="fc" id="L402">            this.mediatorUtils.getParameterUtil().getQueryStringFromEntries(),</span>
            isUsingIndex,
            dataInjection
        );

<span class="fc" id="L407">        urlInjectionFixed = this.mediatorUtils.getCsrfUtil().addQueryStringToken(urlInjectionFixed);</span>
        
        // TODO Keep single check
        try {
<span class="fc" id="L411">            urlObjectFixed = new URI(urlInjectionFixed).toURL();</span>
            
<span class="nc" id="L413">        } catch (MalformedURLException | URISyntaxException e) {</span>
            
<span class="nc" id="L415">            LOGGER.log(</span>
                LogLevelUtil.CONSOLE_ERROR,
<span class="nc" id="L417">                String.format(&quot;Incorrect Url: %s&quot;, e.getMessage())</span>
            );
<span class="fc" id="L419">        }</span>

<span class="fc" id="L421">        msgHeader.put(Header.URL, urlInjectionFixed);</span>
        
<span class="fc" id="L423">        return urlObjectFixed;</span>
    }

    private void initializeHeader(
        boolean isUsingIndex,
        String dataInjection,
        Builder httpRequest
    ) {

<span class="fc bfc" id="L432" title="All 2 branches covered.">        if (!this.mediatorUtils.getParameterUtil().getListHeader().isEmpty()) {</span>

<span class="fc" id="L434">            Stream.of(</span>
<span class="fc" id="L435">                this.buildQuery(</span>
<span class="fc" id="L436">                    this.mediatorMethod.getHeader(),</span>
<span class="fc" id="L437">                    this.mediatorUtils.getParameterUtil().getHeaderFromEntries(),</span>
                    isUsingIndex,
                    dataInjection
                )
<span class="fc" id="L441">                .split(&quot;\\\\r\\\\n&quot;)</span>
            )
<span class="fc" id="L443">            .forEach(header -&gt; {</span>

<span class="fc bfc" id="L445" title="All 2 branches covered.">                if (header.split(&quot;:&quot;).length == 2) {</span>

                    try {  // TODO Should not catch, rethrow or use runtime exception
<span class="fc" id="L448">                        HeaderUtil.sanitizeHeaders(</span>
                            httpRequest,
                            new SimpleEntry&lt;&gt;(
<span class="fc" id="L451">                                header.split(&quot;:&quot;)[0],</span>
<span class="fc" id="L452">                                header.split(&quot;:&quot;)[1]</span>
                            )
                        );
<span class="nc" id="L455">                    } catch (JSqlException e) {</span>
<span class="nc" id="L456">                        LOGGER.log(LogLevelUtil.CONSOLE_ERROR, &quot;Headers sanitizing issue caught already during connection, ignoring&quot;, e);</span>
<span class="fc" id="L457">                    }</span>
                }
<span class="fc" id="L459">            });</span>
        }
<span class="fc" id="L461">    }</span>

    private void initializeRequest(
        boolean isUsingIndex,
        String dataInjection,
        Builder httpRequest,
        Map&lt;Header, Object&gt; msgHeader
    ) {
        
<span class="fc" id="L470">        if (</span>
<span class="fc bfc" id="L471" title="All 2 branches covered.">            this.mediatorUtils.getParameterUtil().getListRequest().isEmpty()</span>
<span class="fc bfc" id="L472" title="All 2 branches covered.">            &amp;&amp; this.mediatorUtils.getCsrfUtil().getTokenCsrf() == null</span>
        ) {
<span class="fc" id="L474">            return;</span>
        }
            
        // Set connection method
        // Active for query string injection too, in that case inject query string still with altered method
        
<span class="fc" id="L480">        var body = new StringBuilder();</span>
        
<span class="fc bfc" id="L482" title="All 2 branches covered.">        if (this.mediatorUtils.getParameterUtil().isRequestSoap()) {</span>
            
<span class="fc" id="L484">            httpRequest.setHeader(HeaderUtil.CONTENT_TYPE_REQUEST, &quot;text/xml&quot;);</span>
            
        } else {
            
<span class="fc" id="L488">            httpRequest.setHeader(HeaderUtil.CONTENT_TYPE_REQUEST, &quot;application/x-www-form-urlencoded&quot;);</span>
        }
   
<span class="fc" id="L491">        this.mediatorUtils.getCsrfUtil().addRequestToken(body);</span>
            
<span class="fc bfc" id="L493" title="All 2 branches covered.">        if (this.mediatorUtils.getConnectionUtil().getTypeRequest().matches(&quot;PUT|POST&quot;)) {</span>
            
<span class="fc bfc" id="L495" title="All 2 branches covered.">            if (this.mediatorUtils.getParameterUtil().isRequestSoap()) {</span>
                
<span class="fc" id="L497">                body.append(</span>
<span class="fc" id="L498">                    this.buildQuery(</span>
<span class="fc" id="L499">                        this.mediatorMethod.getRequest(),</span>
<span class="fc" id="L500">                        this.mediatorUtils.getParameterUtil().getRawRequest(),</span>
                        isUsingIndex,
                        dataInjection
                    )
                    // Invalid XML characters in recent Spring version
                    // Server needs to urldecode, or stop using out of range chars
<span class="fc" id="L506">                    .replace(&quot;\u0001&quot;, &quot;&amp;#01;&quot;)</span>
<span class="fc" id="L507">                    .replace(&quot;\u0003&quot;, &quot;&amp;#03;&quot;)</span>
<span class="fc" id="L508">                    .replace(&quot;\u0004&quot;, &quot;&amp;#04;&quot;)</span>
<span class="fc" id="L509">                    .replace(&quot;\u0005&quot;, &quot;&amp;#05;&quot;)</span>
<span class="fc" id="L510">                    .replace(&quot;\u0006&quot;, &quot;&amp;#06;&quot;)</span>
<span class="fc" id="L511">                    .replace(&quot;\u0007&quot;, &quot;&amp;#07;&quot;)</span>
<span class="fc" id="L512">                    .replace(&quot;+&quot;, &quot;%2B&quot;)  // Prevent replace '+' into 'space' on server side urldecode</span>
                );
                
            } else {
                
<span class="fc" id="L517">                body.append(</span>
<span class="fc" id="L518">                    this.buildQuery(</span>
<span class="fc" id="L519">                        this.mediatorMethod.getRequest(),</span>
<span class="fc" id="L520">                        this.mediatorUtils.getParameterUtil().getRequestFromEntries(),</span>
                        isUsingIndex,
                        dataInjection
                    )
                );
            }
        }
        
<span class="fc" id="L528">        var bodyPublisher = BodyPublishers.ofString(body.toString());</span>
        
<span class="fc" id="L530">        httpRequest.method(</span>
<span class="fc" id="L531">            this.mediatorUtils.getConnectionUtil().getTypeRequest(),</span>
            bodyPublisher
        );
        
<span class="fc" id="L535">        msgHeader.put(Header.POST, body.toString());</span>
<span class="fc" id="L536">    }</span>
    
    private String buildQuery(AbstractMethodInjection methodInjection, String paramLead, boolean isUsingIndex, String sqlTrail) {
        
        String query;
<span class="fc" id="L541">        String paramLeadFixed = paramLead.replace(InjectionModel.STAR, &quot;&lt;tampering&gt;*&lt;/tampering&gt;&quot;);</span>
        
<span class="fc" id="L543">        if (</span>
            // No parameter transformation if method is not selected by user
<span class="fc bfc" id="L545" title="All 2 branches covered.">            this.mediatorUtils.getConnectionUtil().getMethodInjection() != methodInjection</span>
            // No parameter transformation if injection point in URL
<span class="fc bfc" id="L547" title="All 2 branches covered.">            || this.mediatorUtils.getConnectionUtil().getUrlBase().contains(InjectionModel.STAR)</span>
        ) {
            
            // Just pass parameters without any transformation
<span class="fc" id="L551">            query = paramLeadFixed;</span>
            
<span class="fc" id="L553">        } else if (</span>
            // If method is selected by user and URL does not contain injection point
            // but parameters contain an injection point
            // then replace injection point by SQL expression in this parameter
<span class="fc bfc" id="L557" title="All 2 branches covered.">            paramLeadFixed.contains(InjectionModel.STAR)</span>
        ) {
            
<span class="fc" id="L560">            query = this.initializeStarInjection(paramLeadFixed, isUsingIndex, sqlTrail);</span>
            
        } else {
            
<span class="fc" id="L564">            query = this.initializeRawInjection(paramLeadFixed, isUsingIndex, sqlTrail);</span>
        }
        
        // Remove comments except empty /**/
<span class="fc" id="L568">        query = this.cleanQuery(methodInjection, query);</span>
        
        // Add empty comments with space=&gt;/**/
<span class="fc bfc" id="L571" title="All 2 branches covered.">        if (this.mediatorUtils.getConnectionUtil().getMethodInjection() == methodInjection) {</span>
            
<span class="fc" id="L573">            query = this.mediatorUtils.getTamperingUtil().tamper(query);</span>
        }
        
<span class="fc" id="L576">        query = this.applyEncoding(methodInjection, query);</span>
        
<span class="fc" id="L578">        return query;</span>
    }

    private String initializeRawInjection(String paramLead, boolean isUsingIndex, String sqlTrail) {
        
        String query;
        
        // Method is selected by user and there's no injection point
<span class="pc bpc" id="L586" title="1 of 2 branches missed.">        if (!isUsingIndex) {</span>
            // Several SQL expressions does not use indexes in SELECT,
            // like Boolean, Error, Shell and search for character insertion,
            // in that case concat SQL expression to the end of param.
<span class="fc" id="L590">            query = paramLead + sqlTrail;</span>

        } else {
            
            // Concat indexes found for Normal strategy to params
            // and use visible Index for injection
<span class="nc" id="L596">            query = paramLead + this.indexesInUrl.replaceAll(</span>
<span class="nc" id="L597">                String.format(VendorYaml.FORMAT_INDEX, this.mediatorStrategy.getNormal().getVisibleIndex()),</span>
                // Oracle column often contains $, which is reserved for regex.
                // =&gt; need to be escape with quoteReplacement()
<span class="nc" id="L600">                Matcher.quoteReplacement(sqlTrail)</span>
            );
        }

        // Add ending line comment by vendor
<span class="fc" id="L605">        query = query + this.mediatorVendor.getVendor().instance().endingComment();</span>

<span class="fc" id="L607">        return query;</span>
    }

    private String initializeStarInjection(String paramLead, boolean isUsingIndex, String sqlTrail) {
        
        String query;
        
        // Several SQL expressions does not use indexes in SELECT,
        // like Boolean, Error, Shell and search for character insertion,
        // in that case replace injection point by SQL expression.
        // Injection point is always at the end?
<span class="fc bfc" id="L618" title="All 2 branches covered.">        if (!isUsingIndex) {</span>
            
<span class="fc" id="L620">            query = paramLead.replace(</span>
                InjectionModel.STAR,
<span class="fc" id="L622">                sqlTrail + this.mediatorVendor.getVendor().instance().endingComment()</span>
            );
            
        } else {
            
            // Replace injection point by indexes found for Normal strategy
            // and use visible Index for injection
<span class="fc" id="L629">            query = paramLead.replace(</span>
                InjectionModel.STAR,
<span class="fc" id="L631">                this.indexesInUrl.replace(</span>
<span class="fc" id="L632">                    String.format(VendorYaml.FORMAT_INDEX, this.mediatorStrategy.getNormal().getVisibleIndex()),</span>
                    sqlTrail
                )
<span class="fc" id="L635">                + this.mediatorVendor.getVendor().instance().endingComment()</span>
            );
        }
        
<span class="fc" id="L639">        return query;</span>
    }

    /**
     * Dependency:
     * - Tamper space=&gt;comment
     * @param methodInjection
     * @param query
     * @return
     */
    private String cleanQuery(AbstractMethodInjection methodInjection, String query) {
        
<span class="fc" id="L651">        String queryFixed = query;</span>
        
<span class="fc" id="L653">        if (</span>
<span class="fc bfc" id="L654" title="All 2 branches covered.">            methodInjection == this.mediatorMethod.getRequest()</span>
            &amp;&amp; (
<span class="fc bfc" id="L656" title="All 2 branches covered.">                this.mediatorUtils.getParameterUtil().isRequestSoap()</span>
<span class="fc bfc" id="L657" title="All 2 branches covered.">                || this.mediatorUtils.getParameterUtil().isMultipartRequest()</span>
            )
        ) {
            
<span class="fc" id="L661">            queryFixed = StringUtil.removeSqlComment(queryFixed)</span>
<span class="fc" id="L662">                .replace(&quot;+&quot;, &quot; &quot;)</span>
<span class="fc" id="L663">                .replace(&quot;%2b&quot;, &quot;+&quot;)  // Failsafe</span>
<span class="fc" id="L664">                .replace(&quot;%23&quot;, &quot;#&quot;);  // End comment</span>

<span class="fc bfc" id="L666" title="All 2 branches covered.">            if (this.mediatorUtils.getParameterUtil().isMultipartRequest()) {</span>
                // restore linefeed from textfield
<span class="fc" id="L668">                queryFixed = queryFixed.replaceAll(&quot;(?s)\\\\n&quot;, &quot;\r\n&quot;);</span>
            }
            
        } else {
            
<span class="fc" id="L673">            queryFixed = StringUtil.cleanSql(queryFixed);</span>
        }
        
<span class="fc" id="L676">        return queryFixed;</span>
    }

    private String applyEncoding(AbstractMethodInjection methodInjection, String query) {
        
<span class="fc" id="L681">        String queryFixed = query;</span>
        
<span class="fc bfc" id="L683" title="All 2 branches covered.">        if (!this.mediatorUtils.getParameterUtil().isRequestSoap()) {</span>
        
<span class="fc bfc" id="L685" title="All 2 branches covered.">            if (methodInjection == this.mediatorMethod.getQuery()) {</span>
                
                // URL encode each character because no query parameter context
<span class="pc bpc" id="L688" title="1 of 2 branches missed.">                if (!this.mediatorUtils.getPreferencesUtil().isUrlEncodingDisabled()) {</span>

<span class="fc" id="L690">                    queryFixed = queryFixed.replace(&quot;'&quot;, &quot;%27&quot;);</span>
<span class="fc" id="L691">                    queryFixed = queryFixed.replace(&quot;(&quot;, &quot;%28&quot;);</span>
<span class="fc" id="L692">                    queryFixed = queryFixed.replace(&quot;)&quot;, &quot;%29&quot;);</span>
<span class="fc" id="L693">                    queryFixed = queryFixed.replace(&quot;{&quot;, &quot;%7b&quot;);</span>
<span class="fc" id="L694">                    queryFixed = queryFixed.replace(&quot;[&quot;, &quot;%5b&quot;);</span>
<span class="fc" id="L695">                    queryFixed = queryFixed.replace(&quot;]&quot;, &quot;%5d&quot;);</span>
<span class="fc" id="L696">                    queryFixed = queryFixed.replace(&quot;}&quot;, &quot;%7d&quot;);</span>
<span class="fc" id="L697">                    queryFixed = queryFixed.replace(&quot;&gt;&quot;, &quot;%3e&quot;);</span>
<span class="fc" id="L698">                    queryFixed = queryFixed.replace(&quot;&lt;&quot;, &quot;%3c&quot;);</span>
<span class="fc" id="L699">                    queryFixed = queryFixed.replace(&quot;?&quot;, &quot;%3f&quot;);</span>
<span class="fc" id="L700">                    queryFixed = queryFixed.replace(&quot;_&quot;, &quot;%5f&quot;);</span>
<span class="fc" id="L701">                    queryFixed = queryFixed.replace(&quot;,&quot;, &quot;%2c&quot;);</span>
                }

                // HTTP forbidden characters
<span class="fc" id="L705">                queryFixed = queryFixed.replace(StringUtils.SPACE, &quot;+&quot;);</span>
<span class="fc" id="L706">                queryFixed = queryFixed.replace(&quot;`&quot;, &quot;%60&quot;);  // from `${database}`.`${table}`</span>
<span class="fc" id="L707">                queryFixed = queryFixed.replace(&quot;\&quot;&quot;, &quot;%22&quot;);</span>
<span class="fc" id="L708">                queryFixed = queryFixed.replace(&quot;|&quot;, &quot;%7c&quot;);</span>
<span class="fc" id="L709">                queryFixed = queryFixed.replace(&quot;\\&quot;, &quot;%5c&quot;);</span>
                
<span class="fc bfc" id="L711" title="All 2 branches covered.">            } else if (methodInjection != this.mediatorMethod.getRequest()) {</span>
                
                // For cookies in Spring (confirmed, covered by integration tests)
<span class="fc" id="L714">                queryFixed = queryFixed.replace(&quot;+&quot;, &quot;%20&quot;);</span>
<span class="fc" id="L715">                queryFixed = queryFixed.replace(&quot;,&quot;, &quot;%2c&quot;);</span>
<span class="fc" id="L716">                queryFixed = URLDecoder.decode(queryFixed, StandardCharsets.UTF_8);</span>
            }
        }
        
<span class="fc" id="L720">        return queryFixed;</span>
    }
    
    /**
     * Display source code in console.
     * @param message Error message
     * @param source Text to display in console
     */
    public void sendResponseFromSite(String message, String source) {
        
<span class="nc" id="L730">        LOGGER.log(LogLevelUtil.CONSOLE_ERROR, &quot;{}, response from site:&quot;, message);</span>
<span class="nc" id="L731">        LOGGER.log(LogLevelUtil.CONSOLE_ERROR, &quot;&gt;&gt;&gt;{}&quot;, source);</span>
<span class="nc" id="L732">    }</span>
    
    public void displayVersion() {
        
<span class="nc" id="L736">        LOGGER.log(</span>
            LogLevelUtil.CONSOLE_DEFAULT,
            &quot;jSQL Injection v{} on Java {}-{}-{}&quot;,
            this::getVersionJsql,
<span class="nc" id="L740">            () -&gt; SystemUtils.JAVA_VERSION,</span>
<span class="nc" id="L741">            () -&gt; SystemUtils.OS_ARCH,</span>
<span class="nc" id="L742">            () -&gt; SystemUtils.USER_LANGUAGE</span>
        );
<span class="nc" id="L744">    }</span>
    
    
    // Getters and setters

    public String getIndexesInUrl() {
<span class="fc" id="L750">        return this.indexesInUrl;</span>
    }

    public void setIndexesInUrl(String indexesInUrl) {
<span class="fc" id="L754">        this.indexesInUrl = indexesInUrl;</span>
<span class="fc" id="L755">    }</span>

    public boolean shouldErasePreviousInjection() {
<span class="nc" id="L758">        return this.shouldErasePreviousInjection;</span>
    }

    public void setIsScanning(boolean isScanning) {
<span class="fc" id="L762">        this.isScanning = isScanning;</span>
<span class="fc" id="L763">    }</span>

    public String getVersionJsql() {
<span class="fc" id="L766">        return this.propertiesUtil.getProperties().getProperty(&quot;jsql.version&quot;);</span>
    }

    public MediatorUtils getMediatorUtils() {
<span class="fc" id="L770">        return this.mediatorUtils;</span>
    }

    public MediatorVendor getMediatorVendor() {
<span class="fc" id="L774">        return this.mediatorVendor;</span>
    }

    public MediatorMethod getMediatorMethod() {
<span class="fc" id="L778">        return this.mediatorMethod;</span>
    }

    public DataAccess getDataAccess() {
<span class="fc" id="L782">        return this.dataAccess;</span>
    }

    public ResourceAccess getResourceAccess() {
<span class="fc" id="L786">        return this.resourceAccess;</span>
    }

    public MediatorStrategy getMediatorStrategy() {
<span class="fc" id="L790">        return this.mediatorStrategy;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>