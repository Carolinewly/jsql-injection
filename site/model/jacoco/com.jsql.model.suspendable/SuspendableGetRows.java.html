<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SuspendableGetRows.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">model</a> &gt; <a href="index.source.html" class="el_package">com.jsql.model.suspendable</a> &gt; <span class="el_source">SuspendableGetRows.java</span></div><h1>SuspendableGetRows.java</h1><pre class="source lang-java linenums">package com.jsql.model.suspendable;

import com.jsql.model.InjectionModel;
import com.jsql.model.bean.database.AbstractElementDatabase;
import com.jsql.model.bean.database.Table;
import com.jsql.model.bean.util.Interaction;
import com.jsql.model.bean.util.Request;
import com.jsql.model.exception.AbstractSlidingException;
import com.jsql.model.exception.InjectionFailureException;
import com.jsql.model.exception.LoopDetectedSlidingException;
import com.jsql.model.exception.StoppedByUserSlidingException;
import com.jsql.model.injection.strategy.AbstractStrategy;
import com.jsql.util.LogLevelUtil;
import com.jsql.util.StringUtil;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.text.StringEscapeUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.net.URLDecoder;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;

import static com.jsql.model.accessible.DataAccess.*;
import static com.jsql.model.injection.vendor.model.VendorYaml.LIMIT;

/**
 * Get data as chunks by performance query from SQL request.
 * 
 * &lt;pre&gt;
 * Single row format: \4[0-9A-F]*\5[0-9A-F]*c?\4
 * Row separator: \6
 * Tape example: \4xxRow#Xxx\5x\4\6\4xxRow#X+1xx\5x\4\6...\4\1\3\3\7&lt;/pre&gt;
 * 
 * MID and LIMIT move two sliding windows in a 2D array tape in that order.
 * MID skips characters when collected, then LIMIT skips lines when collected.
 * The process can be interrupted by the user (stop/pause).
 */
public class SuspendableGetRows extends AbstractSuspendable {

    /**
     * Log4j logger sent to view.
     */
<span class="fc" id="L48">    private static final Logger LOGGER = LogManager.getRootLogger();</span>

    public SuspendableGetRows(InjectionModel injectionModel) {
<span class="fc" id="L51">        super(injectionModel);</span>
<span class="fc" id="L52">    }</span>

    @Override
    public String run(Object... args) throws AbstractSlidingException {
        
        // TODO Map class
<span class="fc" id="L58">        String initialSqlQuery = (String) args[0];</span>
<span class="fc" id="L59">        String[] sourcePage = (String[]) args[1];</span>
<span class="fc" id="L60">        boolean isMultipleRows = (Boolean) args[2];</span>
<span class="fc" id="L61">        int countRowsToFind = (Integer) args[3];</span>
<span class="fc" id="L62">        AbstractElementDatabase elementDatabase = (AbstractElementDatabase) args[4];</span>
<span class="fc" id="L63">        String metadataInjectionProcess = (String) args[5];</span>
        
<span class="fc" id="L65">        this.injectionModel.getMediatorUtils().getThreadUtil().put(elementDatabase, this);</span>

<span class="fc" id="L67">        AbstractStrategy strategy = this.injectionModel.getMediatorStrategy().getStrategy();</span>
        
        // Fix #14417
<span class="fc bfc" id="L70" title="All 2 branches covered.">        if (strategy == null) {</span>
            
<span class="fc" id="L72">            return StringUtils.EMPTY;</span>
        }
        
        // Stop injection if all rows are found, skip rows and characters collected
<span class="fc" id="L76">        var slidingWindowAllRows = new StringBuilder();</span>
<span class="fc" id="L77">        var slidingWindowCurrentRow = new StringBuilder();</span>
        
<span class="fc" id="L79">        String previousChunk = StringUtils.EMPTY;</span>
<span class="fc" id="L80">        var countAllRows = 0;</span>
<span class="fc" id="L81">        var charPositionInCurrentRow = 1;</span>
<span class="fc" id="L82">        var countInfiniteLoop = 0;</span>
        
<span class="fc" id="L84">        String queryGetRows = this.getQuery(initialSqlQuery, countAllRows);</span>
        
        while (true) {

<span class="fc" id="L88">            this.checkSuspend(strategy, slidingWindowAllRows, slidingWindowCurrentRow);</span>
            
<span class="fc" id="L90">            sourcePage[0] = strategy.inject(queryGetRows, Integer.toString(charPositionInCurrentRow), this, metadataInjectionProcess);</span>
            
            // Parse all the data we have retrieved
<span class="fc" id="L93">            Matcher regexLeadFound = this.parseLeadFound(sourcePage[0], strategy.getPerformanceLength());</span>
<span class="fc" id="L94">            Matcher regexTrailOnlyFound = this.parseTrailOnlyFound(sourcePage[0]);</span>
            
<span class="fc" id="L96">            if (</span>
<span class="pc bpc" id="L97" title="1 of 6 branches missed.">                (!regexLeadFound.find() || regexTrailOnlyFound.find())</span>
                &amp;&amp; isMultipleRows
<span class="pc bpc" id="L99" title="1 of 2 branches missed.">                &amp;&amp; StringUtils.isNotEmpty(slidingWindowAllRows.toString())</span>
            ) {
                
<span class="fc" id="L102">                this.sendProgress(countRowsToFind, countRowsToFind, elementDatabase);</span>
<span class="fc" id="L103">                break;</span>
            }

            // Add the result to the data already found.
            // Fix #40947: OutOfMemoryError on append()
            // Fix #95382: IllegalArgumentException on URLDecoder.decode()
            try {
<span class="fc" id="L110">                String currentChunk = regexLeadFound.group(1);</span>
<span class="fc" id="L111">                currentChunk = decodeUnicode(currentChunk);</span>
<span class="fc" id="L112">                currentChunk = decodeUrl(currentChunk);</span>

<span class="fc" id="L114">                countInfiniteLoop = this.checkInfinite(countInfiniteLoop, previousChunk, currentChunk, slidingWindowCurrentRow, slidingWindowAllRows);</span>
                
<span class="fc" id="L116">                previousChunk = currentChunk;</span>
<span class="fc" id="L117">                slidingWindowCurrentRow.append(currentChunk);</span>
<span class="fc" id="L118">                this.sendChunk(currentChunk);</span>
                
<span class="nc" id="L120">            } catch (IllegalArgumentException | IllegalStateException | OutOfMemoryError e) {</span>
                
<span class="nc" id="L122">                this.endInjection(elementDatabase, e);</span>
<span class="fc" id="L123">            }</span>

            // Check how many rows we have collected from the beginning of that chunk
<span class="fc" id="L126">            int countChunkRows = this.getCountRows(slidingWindowCurrentRow);</span>

<span class="fc" id="L128">            this.sendProgress(countRowsToFind, countAllRows + countChunkRows, elementDatabase);</span>

            // End of rows detected: \1\3\3\7
            // =&gt; \4xxxxxxxx\500\4\6\4...\4\1\3\3\7
<span class="fc bfc" id="L132" title="All 2 branches covered.">            if (</span>
                countChunkRows &gt; 0
<span class="fc bfc" id="L134" title="All 2 branches covered.">                || slidingWindowCurrentRow.toString().matches(&quot;(?s).*&quot;+ TRAIL_RGX +&quot;.*&quot;)</span>
            ) {
                
<span class="fc" id="L137">                this.scrapeTrailJunk(slidingWindowCurrentRow);</span>
                
<span class="fc" id="L139">                slidingWindowAllRows.append(slidingWindowCurrentRow);</span>
                
<span class="fc bfc" id="L141" title="All 2 branches covered.">                if (isMultipleRows) {</span>
                    
<span class="fc" id="L143">                    this.scrap(slidingWindowAllRows);</span>
<span class="fc" id="L144">                    this.scrap(slidingWindowCurrentRow);</span>

<span class="fc" id="L146">                    this.appendRowFixed(slidingWindowAllRows, slidingWindowCurrentRow);</span>

<span class="fc" id="L148">                    countAllRows = this.getCountRows(slidingWindowAllRows);</span>

<span class="fc" id="L150">                    this.sendProgress(countRowsToFind, countAllRows, elementDatabase);</span>

                    // Ending condition: every expected rows have been retrieved.
<span class="fc bfc" id="L153" title="All 2 branches covered.">                    if (countAllRows == countRowsToFind) {</span>
                        
<span class="fc" id="L155">                        break;</span>
                    }

                    // Add the LIMIT statement to the next SQL query and reset variables.
                    // Put the character cursor to the beginning of the line, and reset the result of the current query
<span class="fc" id="L160">                    queryGetRows = this.getQuery(initialSqlQuery, countAllRows);</span>

<span class="fc" id="L162">                    slidingWindowCurrentRow.setLength(0);</span>

                } else {
                    
<span class="fc" id="L166">                    this.sendProgress(countRowsToFind, countRowsToFind, elementDatabase);</span>
<span class="fc" id="L167">                    break;</span>
                }
            }

<span class="fc" id="L171">            charPositionInCurrentRow = slidingWindowCurrentRow.length() + 1;</span>
<span class="fc" id="L172">        }</span>
        
<span class="fc" id="L174">        this.injectionModel.getMediatorUtils().getThreadUtil().remove(elementDatabase);</span>

<span class="fc" id="L176">        return slidingWindowAllRows.toString();</span>
    }

    private String decodeUrl(String currentChunk) {
<span class="pc bpc" id="L180" title="1 of 2 branches missed.">        if (!this.injectionModel.getMediatorUtils().getPreferencesUtil().isUrlDecodeDisabled()) {</span>

            try {
<span class="fc" id="L183">                return URLDecoder.decode(currentChunk, StandardCharsets.UTF_8);  // Transform %00 entities to text</span>
<span class="nc" id="L184">            } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L185">                LOGGER.log(LogLevelUtil.CONSOLE_JAVA, &quot;Decoding fails on UT8, keeping raw result&quot;);</span>
            }
        }
<span class="nc" id="L188">        return currentChunk;</span>
    }

    private String decodeUnicode(String currentChunk) {
<span class="pc bpc" id="L192" title="1 of 2 branches missed.">        if (!this.injectionModel.getMediatorUtils().getPreferencesUtil().isUnicodeDecodeDisabled()) {</span>

<span class="fc" id="L194">            return StringEscapeUtils.unescapeJava(  // transform \u0000 entities to text</span>
<span class="fc" id="L195">                currentChunk.replaceAll(&quot;\\\\u.{0,3}$&quot;, &quot;&quot;)  // remove incorrect entities</span>
            );
        }
<span class="nc" id="L198">        return currentChunk;</span>
    }

    private String getQuery(String initialSqlQuery, int countAllRows) {
        
<span class="fc" id="L203">        return initialSqlQuery.replace(LIMIT, this.injectionModel.getMediatorVendor().getVendor().instance().sqlLimit(countAllRows));</span>
    }

    private void appendRowFixed(StringBuilder slidingWindowAllRows, StringBuilder slidingWindowCurrentRow) {
        
        // Check either if there is more than 1 row and if there is less than 1 complete row
<span class="fc" id="L209">        var regexAtLeastOneRow = Pattern.compile(</span>
<span class="fc" id="L210">            String.format(</span>
                &quot;%s[^\\x01-\\x09\\x0B-\\x0C\\x0E-\\x1F]%s%s%s[^\\x01-\\x09\\x0B-\\x0C\\x0E-\\x1F]+?$&quot;,
                MODE,
                ENCLOSE_VALUE_RGX,
                SEPARATOR_CELL_RGX,
                ENCLOSE_VALUE_RGX
            )
        )
<span class="fc" id="L218">        .matcher(slidingWindowCurrentRow);</span>
        
<span class="fc" id="L220">        var regexRowIncomplete = Pattern.compile(</span>
            MODE
            + ENCLOSE_VALUE_RGX
            + &quot;[^\\x01-\\x03\\x05-\\x09\\x0B-\\x0C\\x0E-\\x1F]+?$&quot;
        )
<span class="fc" id="L225">        .matcher(slidingWindowCurrentRow);</span>

        // If there is more than 1 row, delete the last incomplete one in order to restart properly from it at the next loop,
        // else if there is 1 row but incomplete, mark it as cut with the letter c
<span class="fc bfc" id="L229" title="All 2 branches covered.">        if (regexAtLeastOneRow.find()) {</span>
            
<span class="fc" id="L231">            var allLine = slidingWindowAllRows.toString();</span>
<span class="fc" id="L232">            slidingWindowAllRows.setLength(0);</span>
<span class="fc" id="L233">            slidingWindowAllRows.append(</span>
<span class="fc" id="L234">                Pattern.compile(</span>
                    MODE
                    + ENCLOSE_VALUE_RGX
                    + &quot;[^\\x01-\\x09\\x0B-\\x0C\\x0E-\\x1F]+?$&quot;
                )
<span class="fc" id="L239">                .matcher(allLine)</span>
<span class="fc" id="L240">                .replaceAll(StringUtils.EMPTY)</span>
            );
<span class="fc" id="L242">            LOGGER.log(LogLevelUtil.CONSOLE_INFORM, &quot;Chunk unreliable, reloading row part...&quot;);</span>

<span class="pc bpc" id="L244" title="1 of 2 branches missed.">        } else if (regexRowIncomplete.find()) {</span>
<span class="nc" id="L245">            slidingWindowAllRows.append(StringUtil.hexstr(&quot;05&quot;)).append(&quot;1&quot;).append(StringUtil.hexstr(&quot;0804&quot;));</span>
<span class="nc" id="L246">            LOGGER.log(LogLevelUtil.CONSOLE_INFORM, &quot;Chunk unreliable, keeping row parts only&quot;);</span>
        }
<span class="fc" id="L248">    }</span>

    private void scrapeTrailJunk(StringBuilder slidingWindowCurrentRow) {
        
        // Remove everything after chunk
        // =&gt; \4xxxxxxxx\500\4\6\4...\4 =&gt; \1\3\3\7junk
<span class="fc" id="L254">        var currentRow = slidingWindowCurrentRow.toString();</span>
<span class="fc" id="L255">        slidingWindowCurrentRow.setLength(0);</span>
<span class="fc" id="L256">        slidingWindowCurrentRow.append(</span>
<span class="fc" id="L257">            Pattern.compile(MODE + TRAIL_RGX +&quot;.*&quot;)</span>
<span class="fc" id="L258">            .matcher(currentRow)</span>
<span class="fc" id="L259">            .replaceAll(StringUtils.EMPTY)</span>
        );
<span class="fc" id="L261">    }</span>

    private int getCountRows(StringBuilder slidingWindowCurrentRow) {
        
<span class="fc" id="L265">        var regexAtLeastOneRow = Pattern.compile(</span>
<span class="fc" id="L266">            String.format(</span>
                &quot;%s(%s[^\\x01-\\x09\\x0B-\\x0C\\x0E-\\x1F]*?%s[^\\x01-\\x09\\x0B-\\x0C\\x0E-\\x1F]*?\\x08?%s)&quot;,
                MODE,
                ENCLOSE_VALUE_RGX,
                SEPARATOR_QTE_RGX,
                ENCLOSE_VALUE_RGX
            )
        )
<span class="fc" id="L274">        .matcher(slidingWindowCurrentRow);</span>
        
<span class="fc" id="L276">        var nbCompleteLine = 0;</span>
<span class="fc bfc" id="L277" title="All 2 branches covered.">        while (regexAtLeastOneRow.find()) {</span>
<span class="fc" id="L278">            nbCompleteLine++;</span>
        }
        
<span class="fc" id="L281">        return nbCompleteLine;</span>
    }

    private void endInjection(AbstractElementDatabase searchName, Throwable e) throws InjectionFailureException {
        
        // Premature end of results
        // if it's not the root (empty tree)
<span class="nc bnc" id="L288" title="All 2 branches missed.">        if (searchName != null) {</span>
            
<span class="nc" id="L290">            var request = new Request();</span>
<span class="nc" id="L291">            request.setMessage(Interaction.END_PROGRESS);</span>
<span class="nc" id="L292">            request.setParameters(searchName);</span>
<span class="nc" id="L293">            this.injectionModel.sendToViews(request);</span>
        }

<span class="nc" id="L296">        var messageError = new StringBuilder(&quot;Fetching fails: no data to parse&quot;);</span>
        
<span class="nc bnc" id="L298" title="All 2 branches missed.">        if (searchName != null) {</span>
<span class="nc" id="L299">            messageError.append(&quot; for &quot;).append(StringUtil.detectUtf8(searchName.toString()));</span>
        }
        
<span class="nc bnc" id="L302" title="All 4 branches missed.">        if (searchName instanceof Table &amp;&amp; searchName.getChildCount() &gt; 0) {</span>
<span class="nc" id="L303">            messageError.append(&quot;, check Network tab for logs&quot;);</span>
        }
        
<span class="nc" id="L306">        throw new InjectionFailureException(messageError.toString(), e);</span>
    }

    private void sendChunk(String currentChunk) {
        
<span class="fc" id="L311">        var request = new Request();</span>
<span class="fc" id="L312">        request.setMessage(Interaction.MESSAGE_CHUNK);</span>
<span class="fc" id="L313">        request.setParameters(</span>
<span class="fc" id="L314">            Pattern.compile(MODE + TRAIL_RGX +&quot;.*&quot;)</span>
<span class="fc" id="L315">            .matcher(currentChunk)</span>
<span class="fc" id="L316">            .replaceAll(StringUtils.EMPTY)</span>
<span class="fc" id="L317">            .replace(&quot;\\n&quot;, &quot;\\\\\\n&quot;)</span>
<span class="fc" id="L318">            .replace(&quot;\\r&quot;, &quot;\\\\\\r&quot;)</span>
<span class="fc" id="L319">            .replace(&quot;\\t&quot;, &quot;\\\\\\t&quot;)</span>
        );
        
<span class="fc" id="L322">        this.injectionModel.sendToViews(request);</span>
<span class="fc" id="L323">    }</span>

    // TODO pb for same char string like aaaaaaaaaaaaa...aaaaaaaaaaaaa
    // detected as infinite
    private int checkInfinite(
        int loop,
        String previousChunk,
        String currentChunk,
        StringBuilder slidingWindowCurrentRow,
        StringBuilder slidingWindowAllRows
    ) throws LoopDetectedSlidingException {
        
<span class="fc" id="L335">        int infiniteLoop = loop;</span>
        
<span class="pc bpc" id="L337" title="1 of 2 branches missed.">        if (previousChunk.equals(currentChunk)) {</span>
            
<span class="nc" id="L339">            infiniteLoop++;</span>
<span class="nc bnc" id="L340" title="All 2 branches missed.">            if (infiniteLoop &gt;= 20) {</span>
                
<span class="nc" id="L342">                this.stop();</span>
                
<span class="nc" id="L344">                throw new LoopDetectedSlidingException(</span>
<span class="nc" id="L345">                    slidingWindowAllRows.toString(),</span>
<span class="nc" id="L346">                    slidingWindowCurrentRow.toString()</span>
                );
            }
        }
        
<span class="fc" id="L351">        return infiniteLoop;</span>
    }

    private Matcher parseTrailOnlyFound(String sourcePage) {

<span class="fc" id="L356">        String sourcePageUnicodeDecoded = decodeUnicode(sourcePage);</span>

        // TODO: prevent to find the last line directly: MODE + LEAD + .* + TRAIL_RGX
        // It creates extra query which can be endless if not nullified
<span class="fc" id="L360">        return Pattern.compile(</span>
<span class="fc" id="L361">            String.format(&quot;(?s)%s(?i)%s&quot;, LEAD, TRAIL_RGX)</span>
        )
<span class="fc" id="L363">        .matcher(sourcePageUnicodeDecoded);</span>
    }

    /**
     * After ${lead} tag, gets characters between 1 and maxPerf
     * performanceQuery() gets 65536 characters or less
     * ${lead}blahblah1337      ] : end or limit+1
     * ${lead}blahblah      blah] : continue substr()
     */
    private Matcher parseLeadFound(String sourcePage, String performanceLength) throws InjectionFailureException {
        
        Matcher regexAtLeastOneRow;
        
        try {
<span class="fc" id="L377">            regexAtLeastOneRow = Pattern.compile(</span>
<span class="fc" id="L378">                String.format(&quot;(?s)%s(?i)(.{1,%s})&quot;, LEAD, performanceLength)</span>
            )
<span class="fc" id="L380">            .matcher(sourcePage);</span>
            
<span class="nc" id="L382">        } catch (PatternSyntaxException e) {</span>
            
            // Fix #35382 : PatternSyntaxException null on SQLi(.{1,null})
<span class="nc" id="L385">            throw new InjectionFailureException(&quot;Row parsing failed using capacity&quot;, e);</span>
<span class="fc" id="L386">        }</span>
        
<span class="fc" id="L388">        return regexAtLeastOneRow;</span>
    }

    private void checkSuspend(
        AbstractStrategy strategy,
        StringBuilder slidingWindowAllRows,
        StringBuilder slidingWindowCurrentRow
    ) throws StoppedByUserSlidingException, InjectionFailureException {
        
<span class="pc bpc" id="L397" title="1 of 2 branches missed.">        if (this.isSuspended()) {</span>
            
<span class="nc" id="L399">            throw new StoppedByUserSlidingException(</span>
<span class="nc" id="L400">                slidingWindowAllRows.toString(),</span>
<span class="nc" id="L401">                slidingWindowCurrentRow.toString()</span>
            );
            
<span class="pc bpc" id="L404" title="1 of 2 branches missed.">        } else if (strategy == null) {</span>
            
            // Fix #1905 : NullPointerException on injectionStrategy.inject()
<span class="nc" id="L407">            throw new InjectionFailureException(&quot;Undefined strategy&quot;);</span>
        }
<span class="fc" id="L409">    }</span>

    private void scrap(StringBuilder slidingWindowAllRows) {
        
        // Remove everything not properly attached to the last row:
        // 1. very start of a new row: XXXXX\4[\6\4]$
        // 2. very end of the last row: XXXXX[\500]$

<span class="fc" id="L417">        var allRowsLimit = slidingWindowAllRows.toString();</span>
<span class="fc" id="L418">        slidingWindowAllRows.setLength(0);</span>
<span class="fc" id="L419">        slidingWindowAllRows.append(</span>
<span class="fc" id="L420">            Pattern.compile(</span>
<span class="fc" id="L421">                String.format(</span>
                    &quot;%s(%s%s|%s\\d*)$&quot;,
                    MODE,
                    SEPARATOR_CELL_RGX,
                    ENCLOSE_VALUE_RGX,
                    SEPARATOR_QTE_RGX
                )
            )
<span class="fc" id="L429">            .matcher(allRowsLimit)</span>
<span class="fc" id="L430">            .replaceAll(StringUtils.EMPTY)</span>
        );
<span class="fc" id="L432">    }</span>

    private void sendProgress(int numberToFind, int countProgress, AbstractElementDatabase searchName) {
        
<span class="pc bpc" id="L436" title="1 of 4 branches missed.">        if (numberToFind &gt; 0 &amp;&amp; searchName != null) {</span>
            
<span class="nc" id="L438">            var request = new Request();</span>
<span class="nc" id="L439">            request.setMessage(Interaction.UPDATE_PROGRESS);</span>
<span class="nc" id="L440">            request.setParameters(searchName, countProgress);</span>
<span class="nc" id="L441">            this.injectionModel.sendToViews(request);</span>
        }
<span class="fc" id="L443">    }</span>
    
    public static List&lt;List&lt;String&gt;&gt; parse(String rows) throws InjectionFailureException {
        
        // Parse all the data we have retrieved
<span class="fc" id="L448">        var regexSearch = Pattern.compile(</span>
<span class="fc" id="L449">            String.format(</span>
                &quot;%s%s([^\\x01-\\x09\\x0B-\\x0C\\x0E-\\x1F]*?)%s([^\\x01-\\x09\\x0B-\\x0C\\x0E-\\x1F]*?)(\\x08)?%s&quot;,
                MODE,
                ENCLOSE_VALUE_RGX,
                SEPARATOR_QTE_RGX,
                ENCLOSE_VALUE_RGX
            )
        )
<span class="fc" id="L457">        .matcher(rows);</span>

<span class="pc bpc" id="L459" title="1 of 2 branches missed.">        if (!regexSearch.find()) {</span>
<span class="nc" id="L460">            throw new InjectionFailureException();</span>
        }
        
<span class="fc" id="L463">        regexSearch.reset();</span>

<span class="fc" id="L465">        var rowsFound = 0;</span>
<span class="fc" id="L466">        List&lt;List&lt;String&gt;&gt; listValues = new ArrayList&lt;&gt;();</span>

        // Build a 2D array of strings from the data we have parsed
        // =&gt; row number, occurrence, value1, value2...
<span class="fc bfc" id="L470" title="All 2 branches covered.">        while (regexSearch.find()) {</span>
            
<span class="fc" id="L472">            String values = regexSearch.group(1);</span>
<span class="fc" id="L473">            var instances = Integer.parseInt(regexSearch.group(2));</span>

<span class="fc" id="L475">            listValues.add(new ArrayList&lt;&gt;());</span>
<span class="fc" id="L476">            listValues.get(rowsFound).add(Integer.toString(rowsFound + 1));</span>
<span class="fc" id="L477">            listValues.get(rowsFound).add(&quot;x&quot;+ instances);</span>
            
<span class="fc bfc" id="L479" title="All 2 branches covered.">            for (String cellValue: values.split(&quot;\\x7F&quot;, -1)) {</span>
                
<span class="fc" id="L481">                listValues.get(rowsFound).add(cellValue);</span>
            }

<span class="fc" id="L484">            rowsFound++;</span>
<span class="fc" id="L485">        }</span>
        
<span class="fc" id="L487">        return listValues;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>