<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ShadowPopup.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">view</a> &gt; <a href="index.source.html" class="el_package">com.jsql.view.swing.shadow</a> &gt; <span class="el_source">ShadowPopup.java</span></div><h1>ShadowPopup.java</h1><pre class="source lang-java linenums">package com.jsql.view.swing.shadow;

/*
 * Copyright (c) 2007-2013 JGoodies Software GmbH. All Rights Reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  o Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 *  o Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 *  o Neither the name of JGoodies Software GmbH nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

import com.jsql.util.LogLevelUtil;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import javax.swing.*;
import javax.swing.border.Border;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.List;

/**
 * Does all the magic for getting popups with drop shadows.
 * It adds the drop shadow border to the Popup,
 * in {@code #show} it snapshots the screen background as needed,
 * and in {@code #hide} it cleans up all changes made before.
 *
 * @author Karsten Lentzsch
 * @version $Revision: 1.12 $
 *
 * see com.jgoodies.looks.common.ShadowPopupBorder
 * see com.jgoodies.looks.common.ShadowPopupFactory
 */
<span class="fc" id="L56">public final class ShadowPopup extends Popup {</span>
    
    /**
     * Log4j logger sent to view.
     */
<span class="fc" id="L61">    private static final Logger LOGGER = LogManager.getRootLogger();</span>

    /**
     * Max number of items to store in the cache.
     */
    private static final int MAX_CACHE_SIZE = 5;

    /**
     * The cache to use for ShadowPopups.
     */
    private static List&lt;ShadowPopup&gt; cache;

    /**
     * The singleton instance used to draw all borders.
     */
<span class="fc" id="L76">    private static final Border SHADOW_BORDER = ShadowPopupBorder.getInstance();</span>

    /**
     * The size of the drop shadow.
     */
    private static final int SHADOW_SIZE = 5;

    /**
     * Indicates whether we can make snapshots from screen or not.
     */
<span class="fc" id="L86">    private boolean canSnapshot = true;</span>

    /**
     * The component mouse coordinates are relative to, may be null.
     */
    private Component owner;

    /**
     * The contents of the popup.
     */
    private Component contents;

    /**
     * The desired x and y location of the popup.
     */
    private int x;
    private int y;

    /**
     * The real popup. The #show() and #hide() methods will delegate
     * all calls to these popup.
     */
    private Popup popup;

    /**
     * The border of the contents' parent replaced by SHADOW_BORDER.
     */
    private Border oldBorder;

    /**
     * The old value of the opaque property of the contents' parent.
     */
    private boolean oldOpaque;

    /**
     * The heavy weight container of the popup contents, may be null.
     */
    private Container heavyWeightContainer;

    /**
     * The 'scratch pad' objects used to calculate dirty regions of
     * the screen snapshots.
     *
     * @see #snapshot()
     */
<span class="fc" id="L131">    private static final Point     POINT = new Point();</span>
<span class="fc" id="L132">    private static final Rectangle RECT  = new Rectangle();</span>

    /**
     * Returns a previously used {@code ShadowPopup}, or a new one
     * if none of the popups have been recycled.
     */
    public static Popup getInstance(Component owner, Component contents, int x, int y, Popup delegate) {
        
        ShadowPopup result;
        
<span class="fc" id="L142">        synchronized (ShadowPopup.class) {</span>
            
<span class="fc bfc" id="L144" title="All 2 branches covered.">            if (cache == null) {</span>
                
<span class="fc" id="L146">                cache = new ArrayList&lt;&gt;(MAX_CACHE_SIZE);</span>
            }
            
<span class="fc bfc" id="L149" title="All 2 branches covered.">            if (!cache.isEmpty()) {</span>
                
<span class="fc" id="L151">                result = cache.remove(0);</span>
                
            } else {
                
<span class="fc" id="L155">                result = new ShadowPopup();</span>
            }
<span class="fc" id="L157">        }</span>
        
<span class="fc" id="L159">        result.reset(owner, contents, x, y, delegate);</span>
        
<span class="fc" id="L161">        return result;</span>
    }

    /**
     * Recycles the ShadowPopup.
     */
    private static void recycle(ShadowPopup popup) {
        
<span class="fc" id="L169">        synchronized (ShadowPopup.class) {</span>
            
<span class="pc bpc" id="L171" title="1 of 2 branches missed.">            if (cache.size() &lt; MAX_CACHE_SIZE) {</span>
                
<span class="fc" id="L173">                cache.add(popup);</span>
            }
<span class="fc" id="L175">        }</span>
<span class="fc" id="L176">    }</span>

    public boolean canSnapshot() {
        
<span class="nc" id="L180">        return this.canSnapshot;</span>
    }

    /**
     * Hides and disposes of the {@code Popup}. Once a {@code Popup}
     * has been disposed you should no longer invoke methods on it. A
     * {@code dispose}d {@code Popup} may be reclaimed and later used
     * based on the {@code PopupFactory}. As such, if you invoke methods
     * on a {@code disposed} {@code Popup}, indeterminate
     * behavior will result.&lt;p&gt;
     *
     * In addition to the superclass behavior, we reset the stored
     * horizontal and vertical drop shadows - if any.
     */
    @Override
    public void hide() {
        
<span class="pc bpc" id="L197" title="1 of 2 branches missed.">        if (this.contents == null) {</span>
            
<span class="nc" id="L199">            return;</span>
        }

<span class="fc" id="L202">        JComponent parent = (JComponent) this.contents.getParent();</span>
<span class="fc" id="L203">        this.popup.hide();</span>
        
<span class="pc bpc" id="L205" title="2 of 4 branches missed.">        if (parent != null &amp;&amp; SHADOW_BORDER.equals(parent.getBorder())) {</span>
            
<span class="fc" id="L207">            parent.setBorder(this.oldBorder);</span>
<span class="fc" id="L208">            parent.setOpaque(this.oldOpaque);</span>
<span class="fc" id="L209">            this.oldBorder = null;</span>
            
<span class="fc bfc" id="L211" title="All 2 branches covered.">            if (this.heavyWeightContainer != null) {</span>
                
<span class="fc" id="L213">                parent.putClientProperty(ShadowPopupFactory.PROP_HORIZONTAL_BACKGROUND, null);</span>
<span class="fc" id="L214">                parent.putClientProperty(ShadowPopupFactory.PROP_VERTICAL_BACKGROUND, null);</span>
<span class="fc" id="L215">                this.heavyWeightContainer = null;</span>
            }
        }
        
<span class="fc" id="L219">        this.owner = null;</span>
<span class="fc" id="L220">        this.contents = null;</span>
<span class="fc" id="L221">        this.popup = null;</span>
        
<span class="fc" id="L223">        recycle(this);</span>
<span class="fc" id="L224">    }</span>

    /**
     * Makes the {@code Popup} visible. If the popup has a
     * heavy-weight container, we try to snapshot the background.
     * If the {@code Popup} is currently visible, it remains visible.
     */
    @Override
    public void show() {
        
<span class="fc bfc" id="L234" title="All 2 branches covered.">        if (this.heavyWeightContainer != null) {</span>
            
<span class="fc" id="L236">            this.snapshot();</span>
        }

        // Fix #95477: IllegalArgumentException on show()
        try {
<span class="fc" id="L241">            this.popup.show();</span>
<span class="nc" id="L242">        } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L243">            LOGGER.log(LogLevelUtil.CONSOLE_JAVA, e.getMessage(), e);</span>
<span class="fc" id="L244">        }</span>
<span class="fc" id="L245">    }</span>

    /**
     * Reinitializes this ShadowPopup using the given parameters.
     *
     * @param owner component mouse coordinates are relative to, may be null
     * @param contents the contents of the popup
     * @param x the desired x location of the popup
     * @param y the desired y location of the popup
     * @param popup the popup to wrap
     */
    private void reset(
        Component owner, Component contents, int x, int y,
        Popup popup
    ) {
        
<span class="fc" id="L261">        this.owner = owner;</span>
<span class="fc" id="L262">        this.contents = contents;</span>
<span class="fc" id="L263">        this.popup = popup;</span>
<span class="fc" id="L264">        this.x = x;</span>
<span class="fc" id="L265">        this.y = y;</span>
        
        // Do not install the shadow border when the contents
        // has a preferred size less than or equal to 0.
        // We can't use the size, because it is(0, 0) for new popups.
<span class="fc" id="L270">        var contentsPrefSize = new Dimension();</span>
        
        // Fix #4172: NullPointerException on getPreferredSize()
        // Implementation by javax.swing.plaf.metal.MetalToolTipUI.getPreferredSize()
        try {
<span class="fc" id="L275">            contentsPrefSize = contents.getPreferredSize();</span>
            
<span class="nc" id="L277">        } catch(NullPointerException e) {</span>
            
<span class="nc" id="L279">            LOGGER.log(LogLevelUtil.CONSOLE_JAVA, e, e);</span>
<span class="fc" id="L280">        }</span>
        
<span class="pc bpc" id="L282" title="2 of 4 branches missed.">        if (contentsPrefSize.width &lt;= 0 || contentsPrefSize.height &lt;= 0) {</span>
            
<span class="nc" id="L284">            return;</span>
        }
        
<span class="fc bfc" id="L287" title="All 2 branches covered.">        for (Container p = contents.getParent() ; p != null ; p = p.getParent()) {</span>
            
<span class="pc bpc" id="L289" title="1 of 4 branches missed.">            if (p instanceof JWindow || p instanceof Panel) {</span>
                
                // Workaround for the gray rect problem.
<span class="fc" id="L292">                p.setBackground(contents.getBackground());</span>
<span class="fc" id="L293">                this.heavyWeightContainer = p;</span>
                
<span class="fc" id="L295">                break;</span>
            }
        }
        
<span class="fc" id="L299">        JComponent parent = (JComponent) contents.getParent();</span>
<span class="fc" id="L300">        this.oldOpaque = parent.isOpaque();</span>
<span class="fc" id="L301">        this.oldBorder = parent.getBorder();</span>
<span class="fc" id="L302">        parent.setOpaque(false);</span>
<span class="fc" id="L303">        parent.setBorder(SHADOW_BORDER);</span>
        
        // Pack it because we have changed the border.
<span class="fc bfc" id="L306" title="All 2 branches covered.">        if (this.heavyWeightContainer != null) {</span>
            
<span class="fc" id="L308">            this.heavyWeightContainer.setSize(this.heavyWeightContainer.getPreferredSize());</span>
            
        } else {
            
<span class="fc" id="L312">            parent.setSize(parent.getPreferredSize());</span>
        }
<span class="fc" id="L314">    }</span>

    /**
     * Snapshots the background. The snapshots are stored as client
     * properties of the contents' parent. The next time the border is drawn,
     * this background will be used.&lt;p&gt;
     *
     * Uses a robot on the default screen device to capture the screen
     * region under the drop shadow. Does &lt;em&gt;not&lt;/em&gt; use the window's
     * device, because that may be an outdated device (due to popup reuse)
     * and the robot's origin seems to be adjusted with the default screen
     * device.
     *
     * @see #show()
     * @see com.jgoodies.looks.common.ShadowPopupBorder
     * @see Robot#createScreenCapture(Rectangle)
     */
    private void snapshot() {
        
        try {
<span class="fc" id="L334">            Dimension size = this.heavyWeightContainer.getPreferredSize();</span>
<span class="fc" id="L335">            int width = size.width;</span>
<span class="fc" id="L336">            int height = size.height;</span>

            // Avoid unnecessary and illegal screen captures
            // for degenerated popups.
<span class="pc bpc" id="L340" title="2 of 4 branches missed.">            if (width &lt;= 0 || height &lt;= SHADOW_SIZE) {</span>
                
<span class="nc" id="L342">                return;</span>
            }

<span class="fc" id="L345">            var robot = new Robot(); // uses the default screen device</span>

<span class="fc" id="L347">            RECT.setBounds(this.x, this.y + height - SHADOW_SIZE, width, SHADOW_SIZE);</span>
<span class="fc" id="L348">            BufferedImage hShadowBg = robot.createScreenCapture(RECT);</span>

<span class="fc" id="L350">            RECT.setBounds(this.x + width - SHADOW_SIZE, this.y, SHADOW_SIZE, height - SHADOW_SIZE);</span>
<span class="fc" id="L351">            BufferedImage vShadowBg = robot.createScreenCapture(RECT);</span>

<span class="fc" id="L353">            JComponent parent = (JComponent) this.contents.getParent();</span>
<span class="fc" id="L354">            parent.putClientProperty(ShadowPopupFactory.PROP_HORIZONTAL_BACKGROUND, hShadowBg);</span>
<span class="fc" id="L355">            parent.putClientProperty(ShadowPopupFactory.PROP_VERTICAL_BACKGROUND, vShadowBg);</span>

<span class="fc" id="L357">            Container layeredPane = this.getLayeredPane();</span>
<span class="pc bpc" id="L358" title="1 of 2 branches missed.">            if (layeredPane == null) {</span>
                
                // This could happen if owner is null.
<span class="nc" id="L361">                return;</span>
            }

<span class="fc" id="L364">            int layeredPaneWidth = layeredPane.getWidth();</span>
<span class="fc" id="L365">            int layeredPaneHeight = layeredPane.getHeight();</span>

<span class="fc" id="L367">            POINT.x = this.x;</span>
<span class="fc" id="L368">            POINT.y = this.y;</span>
<span class="fc" id="L369">            SwingUtilities.convertPointFromScreen(POINT, layeredPane);</span>

<span class="fc" id="L371">            this.paintHorizontalSnapshot(width, height, hShadowBg, layeredPane, layeredPaneWidth, layeredPaneHeight);</span>

<span class="fc" id="L373">            this.paintVerticalSnapshot(width, height, vShadowBg, layeredPane, layeredPaneWidth, layeredPaneHeight);</span>
            
<span class="nc" id="L375">        } catch (AWTException | SecurityException | IllegalArgumentException e) {</span>
            
<span class="nc" id="L377">            this.canSnapshot = false;</span>
            
<span class="nc" id="L379">            LOGGER.log(LogLevelUtil.IGNORE, e);</span>
<span class="fc" id="L380">        }</span>
<span class="fc" id="L381">    }</span>

    private void paintVerticalSnapshot(int width, int height, BufferedImage vShadowBg, Container layeredPane, int layeredPaneWidth, int layeredPaneHeight) {
        
        // If needed paint dirty region of the vertical snapshot.
<span class="fc" id="L386">        RECT.x = POINT.x + width - SHADOW_SIZE;</span>
<span class="fc" id="L387">        RECT.y = POINT.y;</span>
<span class="fc" id="L388">        RECT.width = SHADOW_SIZE;</span>
<span class="fc" id="L389">        RECT.height = height - SHADOW_SIZE;</span>

<span class="fc" id="L391">        this.extracted(vShadowBg, layeredPane, layeredPaneWidth, layeredPaneHeight);</span>
<span class="fc" id="L392">    }</span>

    private void paintHorizontalSnapshot(int width, int height, BufferedImage hShadowBg, Container layeredPane, int layeredPaneWidth, int layeredPaneHeight) {
        
        // If needed paint dirty region of the horizontal snapshot.
<span class="fc" id="L397">        RECT.x = POINT.x;</span>
<span class="fc" id="L398">        RECT.y = POINT.y + height - SHADOW_SIZE;</span>
<span class="fc" id="L399">        RECT.width = width;</span>
<span class="fc" id="L400">        RECT.height = SHADOW_SIZE;</span>

<span class="fc" id="L402">        this.extracted(hShadowBg, layeredPane, layeredPaneWidth, layeredPaneHeight);</span>
<span class="fc" id="L403">    }</span>

    private void extracted(BufferedImage shadowBg, Container layeredPane, int layeredPaneWidth, int layeredPaneHeight) {
        
<span class="pc bpc" id="L407" title="1 of 2 branches missed.">        if ((RECT.x + RECT.width) &gt; layeredPaneWidth) {</span>
            
<span class="fc" id="L409">            RECT.width = layeredPaneWidth - RECT.x;</span>
        }
        
<span class="pc bpc" id="L412" title="1 of 2 branches missed.">        if ((RECT.y + RECT.height) &gt; layeredPaneHeight) {</span>
            
<span class="nc" id="L414">            RECT.height = layeredPaneHeight - RECT.y;</span>
        }
        
<span class="fc bfc" id="L417" title="All 2 branches covered.">        if (!RECT.isEmpty()) {</span>
            
<span class="fc" id="L419">            Graphics g = shadowBg.createGraphics();</span>
<span class="fc" id="L420">            g.translate(-RECT.x, -RECT.y);</span>
<span class="fc" id="L421">            g.setClip(RECT);</span>
            
<span class="pc bpc" id="L423" title="1 of 2 branches missed.">            if (layeredPane instanceof JComponent) {</span>
                
<span class="fc" id="L425">                JComponent c = (JComponent) layeredPane;</span>
<span class="fc" id="L426">                boolean doubleBuffered = c.isDoubleBuffered();</span>
<span class="fc" id="L427">                c.setDoubleBuffered(false);</span>
<span class="fc" id="L428">                ShadowPopup.paintAll(c, g);</span>
<span class="fc" id="L429">                c.setDoubleBuffered(doubleBuffered);</span>
                
<span class="fc" id="L431">            } else {</span>
                
<span class="nc" id="L433">                layeredPane.paintAll(g);</span>
            }
            
<span class="fc" id="L436">            g.dispose();</span>
        }
<span class="fc" id="L438">    }</span>
    
    private static void paintAll(JComponent c, Graphics g) {
        
        // Fix #3127, Fix #6772, Fix #48907: Multiple Exceptions on paintAll()
        try {
<span class="fc" id="L444">            c.paintAll(g);</span>
            
<span class="nc" id="L446">        } catch (IllegalArgumentException | ArrayIndexOutOfBoundsException | NullPointerException e) {</span>
            
<span class="nc" id="L448">            LOGGER.log(LogLevelUtil.CONSOLE_JAVA, e.getMessage(), e);</span>
<span class="fc" id="L449">        }</span>
<span class="fc" id="L450">    }</span>

    /**
     * @return the top level layered pane which contains the owner.
     */
    private Container getLayeredPane() {
        
        // The code below is copied from PopupFactory#LightWeightPopup#show()
<span class="fc" id="L458">        Container parent = null;</span>
        
<span class="pc bpc" id="L460" title="1 of 2 branches missed.">        if (this.owner != null) {</span>
            
<span class="pc bpc" id="L462" title="1 of 2 branches missed.">            parent = this.owner instanceof Container</span>
<span class="fc" id="L463">                ? (Container) this.owner</span>
<span class="pc" id="L464">                : this.owner.getParent();</span>
        }
        
        // Try to find a JLayeredPane and Window to add
<span class="pc bpc" id="L468" title="1 of 2 branches missed.">        for (Container p = parent; p != null; p = p.getParent()) {</span>
            
<span class="fc bfc" id="L470" title="All 2 branches covered.">            if (p instanceof JRootPane) {</span>
                
<span class="pc bpc" id="L472" title="1 of 2 branches missed.">                if (!(p.getParent() instanceof JInternalFrame)) {</span>
                    
<span class="fc" id="L474">                    parent = ((JRootPane) p).getLayeredPane();</span>
                }
                // Continue, so that if there is a higher JRootPane, we'll
                // pick it up.
                
<span class="fc bfc" id="L479" title="All 2 branches covered.">            } else if (p instanceof Window) {</span>
                
<span class="pc bpc" id="L481" title="1 of 2 branches missed.">                if (parent == null) {</span>
<span class="nc" id="L482">                    parent = p;</span>
                }
                
                break;
            }
        }
        
<span class="fc" id="L489">        return parent;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>