<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SQLToken.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">view</a> &gt; <a href="index.source.html" class="el_package">com.jsql.view.swing.sql.lexer.syntax</a> &gt; <span class="el_source">SQLToken.java</span></div><h1>SQLToken.java</h1><pre class="source lang-java linenums">/*
 * This file is part of a syntax highlighting package
 * Copyright (C) 2002  Stephen Ostermiller
 * http://ostermiller.org/contact.pl?regarding=Syntax+Highlighting
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * See COPYING.TXT for details.
 */
package com.jsql.view.swing.sql.lexer.syntax;

/**
 * A SQLToken is a token that is returned by a lexer that is lexing an SQL
 * source file. It has several attributes describing the token: The type of
 * token, the text of the token, the line number on which it occurred, the
 * number of characters into the input at which it started, and similarly, the
 * number of characters into the input at which it ended. &lt;br&gt;
 */
public class SQLToken extends Token {
    /**
     * A reserved word (keyword)
     */
    public static final int RESERVED_WORD = 0x100;

    /**
     * A variable, name, or other identifier
     */
    public static final int IDENTIFIER = 0x200;

    /**
     * A string literal
     */
    public static final int LITERAL_STRING = 0x300;
    /**
     * A bit-string
     */
    public static final int LITERAL_BIT_STRING = 0x310;
    /**
     * An integer
     */
    public static final int LITERAL_INTEGER = 0x320;
    /**
     * A floating point
     */
    public static final int LITERAL_FLOAT = 0x330;

    /**
     * A separator
     */
    public static final int SEPARATOR = 0x400;

    /**
     * An operator
     */
    public static final int OPERATOR = 0x500;

    /**
     * C style comment, (except possibly nested)
     */
    public static final int COMMENT_TRADITIONAL = 0xD00;

    /**
     * a -- to end of line comment.
     */
    public static final int COMMENT_END_OF_LINE = 0xD10;

    /**
     * White space
     */
    public static final int WHITE_SPACE = 0xE00;

    /**
     * An error
     */
    public static final int ERROR = 0xF00;
    /**
     * An comment start embedded in an operator
     */
    public static final int ERROR_UNCLOSED_COMMENT = 0xF02;
    /**
     * An comment start embedded in an operator
     */
    public static final int ERROR_UNCLOSED_STRING = 0xF03;
    /**
     * An comment start embedded in an operator
     */
    public static final int ERROR_UNCLOSED_BIT_STRING = 0xF04;
    /**
     * An comment start embedded in an operator
     */
    public static final int ERROR_BAD_BIT_STRING = 0xF05;

    private final int id;
    private final String contents;
    private final int lineNumber;
    private final int charBegin;
    private final int charEnd;
    private final int state;

    /**
     * Create a new token. The constructor is typically called by the lexer
     *
     * @param id
     *            the id number of the token
     * @param contents
     *            A string representing the text of the token
     * @param lineNumber
     *            the line number of the input on which this token started
     * @param charBegin
     *            the offset into the input in characters at which this token
     *            started
     * @param charEnd
     *            the offset into the input in characters at which this token
     *            ended
     */
    public SQLToken(int id, String contents, int lineNumber, int charBegin, int charEnd) {
<span class="nc" id="L125">        this(id, contents, lineNumber, charBegin, charEnd, Token.UNDEFINED_STATE);</span>
<span class="nc" id="L126">    }</span>

    /**
     * Create a new token. The constructor is typically called by the lexer
     *
     * @param id
     *            the id number of the token
     * @param contents
     *            A string representing the text of the token
     * @param lineNumber
     *            the line number of the input on which this token started
     * @param charBegin
     *            the offset into the input in characters at which this token
     *            started
     * @param charEnd
     *            the offset into the input in characters at which this token
     *            ended
     * @param state
     *            the state the tokenizer is in after returning this token.
     */
<span class="fc" id="L146">    public SQLToken(int id, String contents, int lineNumber, int charBegin, int charEnd, int state) {</span>
<span class="fc" id="L147">        this.id = id;</span>
<span class="fc" id="L148">        this.contents = contents;</span>
<span class="fc" id="L149">        this.lineNumber = lineNumber;</span>
<span class="fc" id="L150">        this.charBegin = charBegin;</span>
<span class="fc" id="L151">        this.charEnd = charEnd;</span>
<span class="fc" id="L152">        this.state = state;</span>
<span class="fc" id="L153">    }</span>

    /**
     * Get an integer representing the state the tokenizer is in after returning
     * this token. Those who are interested in incremental tokenizing for
     * performance reasons will want to use this method to figure out where the
     * tokenizer may be restarted. The tokenizer starts in Token.INITIAL_STATE,
     * so any time that it reports that it has returned to this state, the
     * tokenizer may be restarted from there.
     */
    @Override
    public int getState() {
<span class="fc" id="L165">        return this.state;</span>
    }

    /**
     * get the ID number of this token
     * 
     * @return the id number of the token
     */
    @Override
    public int getID() {
<span class="nc" id="L175">        return this.id;</span>
    }

    /**
     * get the contents of this token
     * 
     * @return A string representing the text of the token
     */
    @Override
    public String getContents() {
<span class="nc" id="L185">        return this.contents;</span>
    }

    /**
     * get the line number of the input on which this token started
     * 
     * @return the line number of the input on which this token started
     */
    @Override
    public int getLineNumber() {
<span class="nc" id="L195">        return this.lineNumber;</span>
    }

    /**
     * get the offset into the input in characters at which this token started
     *
     * @return the offset into the input in characters at which this token
     *         started
     */
    @Override
    public int getCharBegin() {
<span class="fc" id="L206">        return this.charBegin;</span>
    }

    /**
     * get the offset into the input in characters at which this token ended
     *
     * @return the offset into the input in characters at which this token ended
     */
    @Override
    public int getCharEnd() {
<span class="fc" id="L216">        return this.charEnd;</span>
    }

    /**
     * Checks this token to see if it is a reserved word. Reserved words are
     * explained in &lt;A Href=http://java.sun.com/docs/books/jls/html/&gt;Java
     * Language Specification&lt;/A&gt;.
     *
     * @return true if this token is a reserved word, false otherwise
     */
    public boolean isReservedWord() {
<span class="fc bfc" id="L227" title="All 2 branches covered.">        return (this.id &gt;&gt; 8) == 0x1;</span>
    }

    /**
     * Checks this token to see if it is an identifier. Identifiers are
     * explained in &lt;A Href=http://java.sun.com/docs/books/jls/html/&gt;Java
     * Language Specification&lt;/A&gt;.
     *
     * @return true if this token is an identifier, false otherwise
     */
    public boolean isIdentifier() {
<span class="fc bfc" id="L238" title="All 2 branches covered.">        return (this.id &gt;&gt; 8) == 0x2;</span>
    }

    /**
     * Checks this token to see if it is a literal. Literals are explained in &lt;A
     * Href=http://java.sun.com/docs/books/jls/html/&gt;Java Language
     * Specification&lt;/A&gt;.
     *
     * @return true if this token is a literal, false otherwise
     */
    public boolean isLiteral() {
<span class="fc bfc" id="L249" title="All 2 branches covered.">        return (this.id &gt;&gt; 8) == 0x3;</span>
    }

    /**
     * Checks this token to see if it is a Separator. Separators are explained
     * in &lt;A Href=http://java.sun.com/docs/books/jls/html/&gt;Java Language
     * Specification&lt;/A&gt;.
     *
     * @return true if this token is a Separator, false otherwise
     */
    public boolean isSeparator() {
<span class="fc bfc" id="L260" title="All 2 branches covered.">        return (this.id &gt;&gt; 8) == 0x4;</span>
    }

    /**
     * Checks this token to see if it is a Operator. Operators are explained in
     * &lt;A Href=http://java.sun.com/docs/books/jls/html/&gt;Java Language
     * Specification&lt;/A&gt;.
     *
     * @return true if this token is a Operator, false otherwise
     */
    public boolean isOperator() {
<span class="fc bfc" id="L271" title="All 2 branches covered.">        return (this.id &gt;&gt; 8) == 0x5;</span>
    }

    /**
     * Checks this token to see if it is a comment.
     * 
     * @return true if this token is a comment, false otherwise
     */
    @Override
    public boolean isComment() {
<span class="fc bfc" id="L281" title="All 2 branches covered.">        return (this.id &gt;&gt; 8) == 0xD;</span>
    }

    /**
     * Checks this token to see if it is White Space. Usually tabs, line breaks,
     * form feed, spaces, etc.
     * 
     * @return true if this token is White Space, false otherwise
     */
    @Override
    public boolean isWhiteSpace() {
<span class="fc bfc" id="L292" title="All 2 branches covered.">        return (this.id &gt;&gt; 8) == 0xE;</span>
    }

    /**
     * Checks this token to see if it is an Error. Unfinished comments, numbers
     * that are too big, unclosed strings, etc.
     * 
     * @return true if this token is an Error, false otherwise
     */
    @Override
    public boolean isError() {
<span class="pc bpc" id="L303" title="1 of 2 branches missed.">        return (this.id &gt;&gt; 8) == 0xF;</span>
    }

    /**
     * A description of this token. The description should be appropriate for
     * syntax highlighting. For example &quot;comment&quot; is returned for a comment.
     *
     * @return a description of this token.
     */
    @Override
    public String getDescription() {
<span class="fc bfc" id="L314" title="All 2 branches covered.">        if (this.isReservedWord()) {</span>
<span class="fc" id="L315">            return &quot;reservedWord&quot;;</span>
<span class="fc bfc" id="L316" title="All 2 branches covered.">        } else if (this.isIdentifier()) {</span>
<span class="fc" id="L317">            return &quot;identifier&quot;;</span>
<span class="fc bfc" id="L318" title="All 2 branches covered.">        } else if (this.isLiteral()) {</span>
<span class="fc" id="L319">            return &quot;literal&quot;;</span>
<span class="fc bfc" id="L320" title="All 2 branches covered.">        } else if (this.isSeparator()) {</span>
<span class="fc" id="L321">            return &quot;separator&quot;;</span>
<span class="fc bfc" id="L322" title="All 2 branches covered.">        } else if (this.isOperator()) {</span>
<span class="fc" id="L323">            return &quot;operator&quot;;</span>
<span class="fc bfc" id="L324" title="All 2 branches covered.">        } else if (this.isComment()) {</span>
<span class="fc" id="L325">            return &quot;comment&quot;;</span>
<span class="fc bfc" id="L326" title="All 2 branches covered.">        } else if (this.isWhiteSpace()) {</span>
<span class="fc" id="L327">            return &quot;whitespace&quot;;</span>
<span class="pc bpc" id="L328" title="1 of 2 branches missed.">        } else if (this.isError()) {</span>
<span class="fc" id="L329">            return &quot;error&quot;;</span>
        } else {
<span class="nc" id="L331">            return &quot;unknown&quot;;</span>
        }
    }

    /**
     * get a String that explains the error, if this token is an error.
     * 
     * @return a String that explains the error, if this token is an error, null
     *         otherwise.
     */
    @Override
    public String errorString() {
        String s;
<span class="nc bnc" id="L344" title="All 2 branches missed.">        if (this.isError()) {</span>
<span class="nc" id="L345">            s = &quot;Error on line &quot; + this.lineNumber + &quot;: &quot;;</span>
<span class="nc bnc" id="L346" title="All 6 branches missed.">            switch (this.id) {</span>
            case ERROR:
<span class="nc" id="L348">                s += &quot;Unexpected token: &quot; + this.contents;</span>
<span class="nc" id="L349">                break;</span>
            case ERROR_UNCLOSED_COMMENT:
<span class="nc" id="L351">                s += &quot;Unclosed comment: &quot; + this.contents;</span>
<span class="nc" id="L352">                break;</span>
            case ERROR_UNCLOSED_STRING:
<span class="nc" id="L354">                s += &quot;Unclosed string literal: &quot; + this.contents;</span>
<span class="nc" id="L355">                break;</span>
            case ERROR_UNCLOSED_BIT_STRING:
<span class="nc" id="L357">                s += &quot;Unclosed bit-string literal: &quot; + this.contents;</span>
<span class="nc" id="L358">                break;</span>
            case ERROR_BAD_BIT_STRING:
<span class="nc" id="L360">                s += &quot;Bit-strings can only contain 0 and 1: &quot; + this.contents;</span>
<span class="nc" id="L361">                break;</span>
            }

        } else {
<span class="nc" id="L365">            s = null;</span>
        }
<span class="nc" id="L367">        return s;</span>
    }

    /**
     * get a representation of this token as a human readable string. The format
     * of this string is subject to change and should only be used for debugging
     * purposes.
     *
     * @return a string representation of this token
     */
    @Override
    public String toString() {
<span class="nc" id="L379">        return &quot;Token #&quot; + Integer.toHexString(this.id) + &quot;: &quot; + this.getDescription() + &quot; Line &quot; + this.lineNumber + &quot; from &quot;</span>
                + this.charBegin + &quot; to &quot; + this.charEnd + &quot; : &quot; + this.contents;
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>