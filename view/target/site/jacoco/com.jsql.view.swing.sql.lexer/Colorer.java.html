<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Colorer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">view</a> &gt; <a href="index.source.html" class="el_package">com.jsql.view.swing.sql.lexer</a> &gt; <span class="el_source">Colorer.java</span></div><h1>Colorer.java</h1><pre class="source lang-java linenums">/*
 * This file is part of the programmer editor demo
 * Copyright (C) 2001-2005 Stephen Ostermiller
 * http://ostermiller.org/contact.pl?regarding=Syntax+Highlighting
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * See COPYING.TXT for details.
 */
package com.jsql.view.swing.sql.lexer;

import com.jsql.util.LogLevelUtil;
import com.jsql.view.swing.sql.lexer.syntax.Lexer;
import com.jsql.view.swing.sql.lexer.syntax.Token;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import javax.swing.text.AttributeSet;
import java.io.IOException;
import java.lang.ref.WeakReference;
import java.util.*;

/**
 * Run the Syntax Highlighting as a separate thread. Things that need to be
 * colored are messaged to the thread and put in a list.
 */
class Colorer extends Thread {
    
    /**
     * Log4j logger sent to view.
     */
<span class="fc" id="L40">    private static final Logger LOGGER = LogManager.getRootLogger();</span>
    
    /**
     * A simple wrapper representing something that needs to be colored. Placed
     * into an object so that it can be stored in a Vector.
     */
    private static class RecolorEvent {
        
        private int position;
        
        private int adjustment;

<span class="fc" id="L52">        public RecolorEvent(int position, int adjustment) {</span>
<span class="fc" id="L53">            this.position = position;</span>
<span class="fc" id="L54">            this.adjustment = adjustment;</span>
<span class="fc" id="L55">        }</span>

        public int getPosition() {
<span class="fc" id="L58">            return this.position;</span>
        }

        public void setPosition(int position) {
<span class="nc" id="L62">            this.position = position;</span>
<span class="nc" id="L63">        }</span>

        public int getAdjustment() {
<span class="fc" id="L66">            return this.adjustment;</span>
        }

        public void setAdjustment(int adjustment) {
<span class="fc" id="L70">            this.adjustment = adjustment;</span>
<span class="fc" id="L71">        }</span>
    }
    
    /**
     * Stores the document we are coloring. We use a WeakReference
     * so that the document is eligible for garbage collection when
     * it is no longer being used. At that point, this thread will
     * shut down itself.
     */
    private final WeakReference&lt;HighlightedDocument&gt; document;

    /**
     * Keep a list of places in the file that it is safe to restart the
     * highlighting. This happens whenever the lexer reports that it has
     * returned to its initial state. Since this list needs to be sorted and
     * we need to be able to retrieve ranges from it, it is stored in a
     * balanced tree.
     */
<span class="fc" id="L89">    private final TreeSet&lt;DocPosition&gt; iniPositions = new TreeSet&lt;&gt;(DocPositionComparator.instance);</span>

    /**
     * As we go through and remove invalid positions we will also be finding
     * new valid positions. Since the position list cannot be deleted from
     * and written to at the same time, we will keep a list of the new
     * positions and simply add it to the list of positions once all the old
     * positions have been removed.
     */
<span class="fc" id="L98">    private final HashSet&lt;DocPosition&gt; newPositions = new HashSet&lt;&gt;();</span>

    /**
     * Vector that stores the communication between the two threads.
     */
<span class="fc" id="L103">    private final LinkedList&lt;RecolorEvent&gt; events = new LinkedList&lt;&gt;();</span>

    /**
     * When accessing the linked list, we need to create a critical section.
     * we will synchronize on this object to ensure that we don't get unsafe
     * thread behavior.
     */
<span class="fc" id="L110">    private final Object eventsLock = new Object();</span>

    /**
     * The amount of change that has occurred before the place in the
     * document that we are currently highlighting (lastPosition).
     */
<span class="fc" id="L116">    private volatile int change = 0;</span>

    /**
     * The last position colored
     */
<span class="fc" id="L121">    private volatile int lastPosition = -1;</span>

    /**
     * Creates the coloring thread for the given document.
     * 
     * @param document The document to be colored.
     */
    public Colorer(HighlightedDocument document) {
<span class="fc" id="L129">        super(&quot;ThreadColorer&quot;);</span>
<span class="fc" id="L130">        this.document = new WeakReference&lt;&gt;(document);</span>
<span class="fc" id="L131">    }</span>

    /**
     * Tell the Syntax Highlighting thread to take another look at this
     * section of the document. It will process this as a FIFO. This method
     * should be done inside a docLock.
     */
    public void color(int position, int adjustment) {
        
        // figure out if this adjustment effects the current run.
        // if it does, then adjust the place in the document
        // that gets highlighted.
<span class="pc bpc" id="L143" title="1 of 2 branches missed.">        if (position &lt; this.lastPosition) {</span>
            
<span class="nc bnc" id="L145" title="All 2 branches missed.">            if (this.lastPosition &lt; position - adjustment) {</span>
                
<span class="nc" id="L147">                this.change -= this.lastPosition - position;</span>
                
            } else {
                
<span class="nc" id="L151">                this.change += adjustment;</span>
            }
        }
        
<span class="fc" id="L155">        synchronized (this.eventsLock) {</span>
            
<span class="fc bfc" id="L157" title="All 2 branches covered.">            if(!this.events.isEmpty()) {</span>
                
                // check whether to coalesce with current last element
<span class="fc" id="L160">                RecolorEvent curLast = this.events.getLast();</span>
                
<span class="pc bpc" id="L162" title="3 of 4 branches missed.">                if(adjustment &lt; 0 &amp;&amp; curLast.getAdjustment() &lt; 0) {</span>
                    
                    // both are removals
<span class="nc bnc" id="L165" title="All 2 branches missed.">                    if(position == curLast.getPosition()) {</span>
                        
<span class="nc" id="L167">                        curLast.setAdjustment(curLast.getAdjustment() + adjustment);</span>
<span class="nc" id="L168">                        return;</span>
                    }
                    
<span class="pc bpc" id="L171" title="2 of 4 branches missed.">                } else if(adjustment &gt;= 0 &amp;&amp; curLast.getAdjustment() &gt;= 0) {</span>
                    
                    // both are insertions
<span class="pc bpc" id="L174" title="1 of 2 branches missed.">                    if(position == curLast.getPosition() + curLast.getAdjustment()) {</span>
                        
<span class="fc" id="L176">                        curLast.setAdjustment(curLast.getAdjustment() + adjustment);</span>
<span class="fc" id="L177">                        return;</span>
                        
<span class="nc bnc" id="L179" title="All 2 branches missed.">                    } else if(curLast.getPosition() == position + adjustment) {</span>
                        
<span class="nc" id="L181">                        curLast.setPosition(position);</span>
<span class="nc" id="L182">                        curLast.setAdjustment(curLast.getAdjustment() + adjustment);</span>
                        
<span class="nc" id="L184">                        return;</span>
                    }
                }
            }
            
<span class="fc" id="L189">            this.events.add(new RecolorEvent(position, adjustment));</span>
<span class="fc" id="L190">            this.eventsLock.notifyAll();</span>
<span class="fc" id="L191">        }</span>
<span class="fc" id="L192">    }</span>

    /**
     * The colorer runs forever and may sleep for long periods of time. It
     * should be interrupted every time there is something for it to do.
     */
    @Override
    public void run() {
        
<span class="pc bpc" id="L201" title="1 of 2 branches missed.">        while (this.document.get() != null) {</span>
            
            try {
<span class="fc" id="L204">                RecolorEvent re = new RecolorEvent(0, 0);</span>
<span class="fc" id="L205">                synchronized (this.eventsLock) {</span>
                    
                    // get the next event to process - stalling until the
                    // event becomes available
<span class="pc bpc" id="L209" title="1 of 4 branches missed.">                    while(this.events.isEmpty() &amp;&amp; this.document.get() != null) {</span>
                        
                        // stop waiting after a second in case document
                        // has been cleared.
<span class="fc" id="L213">                        this.eventsLock.wait(1000);</span>
                    }
                    
<span class="pc bpc" id="L216" title="1 of 2 branches missed.">                    if (!this.events.isEmpty()) {</span>
                        
<span class="fc" id="L218">                        re = this.events.removeFirst();</span>
                    }
<span class="fc" id="L220">                }</span>
<span class="fc" id="L221">                this.processEvent(re.getPosition(), re.getAdjustment());</span>
<span class="fc" id="L222">                Thread.sleep(100);</span>
                
<span class="nc" id="L224">            } catch(InterruptedException e) {</span>
                
<span class="nc" id="L226">                LOGGER.log(LogLevelUtil.IGNORE, e, e);</span>
<span class="nc" id="L227">                Thread.currentThread().interrupt();</span>
<span class="pc" id="L228">            }</span>
        }
<span class="nc" id="L230">    }</span>
    
    private void processEvent(int position, int adjustment) {
        
<span class="fc" id="L234">        HighlightedDocument doc = this.document.get();</span>
<span class="pc bpc" id="L235" title="1 of 2 branches missed.">        if(doc == null) {</span>
            
<span class="nc" id="L237">            return;</span>
        }
        
        // slurp everything up into local variables in case another
        // thread changes them during coloring process
<span class="fc" id="L242">        AttributeSet globalStyle = doc.getGlobalStyle();</span>
<span class="fc" id="L243">        Lexer syntaxLexer = doc.getSyntaxLexer();</span>
<span class="fc" id="L244">        DocumentReader documentReader = doc.getDocumentReader();</span>
<span class="fc" id="L245">        Object docLock = doc.getDocumentLock();</span>

<span class="pc bpc" id="L247" title="1 of 2 branches missed.">        if (globalStyle != null) {</span>
            
<span class="nc" id="L249">            int start = Math.min(position, position + adjustment);</span>
<span class="nc" id="L250">            int stop = Math.max(position, position + adjustment);</span>
            
<span class="nc" id="L252">            synchronized (docLock) {</span>
                
<span class="nc" id="L254">                doc.setCharacterAttributes(start, stop - start, globalStyle, true);</span>
<span class="nc" id="L255">            }</span>
            
<span class="nc" id="L257">            return;</span>
        }
        
        SortedSet&lt;DocPosition&gt; workingSet;
        Iterator&lt;DocPosition&gt; workingIt;
<span class="fc" id="L262">        DocPosition startRequest = new DocPosition(position);</span>
<span class="fc" id="L263">        DocPosition endRequest = new DocPosition(position + Math.abs(adjustment));</span>
        DocPosition dp;
<span class="fc" id="L265">        DocPosition dpStart = null;</span>
        DocPosition dpEnd;

        // find the starting position. We must start at least one
        // token before the current position
        try {
            // all the good positions before
<span class="fc" id="L272">            workingSet = this.iniPositions.headSet(startRequest);</span>
            // the last of the stuff before
<span class="nc" id="L274">            dpStart = workingSet.last();</span>
            
<span class="fc" id="L276">        } catch (NoSuchElementException e) {</span>
            
            // if there were no good positions before the requested
            // start,
            // we can always start at the very beginning.
<span class="fc" id="L281">            dpStart = new DocPosition(0);</span>
            
<span class="fc" id="L283">            LOGGER.log(LogLevelUtil.IGNORE, e);</span>
<span class="nc" id="L284">        }</span>

        // if stuff was removed, take any removed positions off the
        // list.
<span class="pc bpc" id="L288" title="1 of 2 branches missed.">        if (adjustment &lt; 0) {</span>
            
<span class="nc" id="L290">            workingSet = this.iniPositions.subSet(startRequest, endRequest);</span>
<span class="nc" id="L291">            workingIt = workingSet.iterator();</span>
            
<span class="nc bnc" id="L293" title="All 2 branches missed.">            while (workingIt.hasNext()) {</span>
                
<span class="nc" id="L295">                workingIt.next();</span>
<span class="nc" id="L296">                workingIt.remove();</span>
            }
        }

        // adjust the positions of everything after the
        // insertion/removal.
<span class="fc" id="L302">        workingSet = this.iniPositions.tailSet(startRequest);</span>
<span class="fc" id="L303">        workingIt = workingSet.iterator();</span>
<span class="fc bfc" id="L304" title="All 2 branches covered.">        while (workingIt.hasNext()) {</span>
            
<span class="fc" id="L306">            workingIt.next().adjustPosition(adjustment);</span>
        }

        // now go through and highlight as much as needed
<span class="fc" id="L310">        workingSet = this.iniPositions.tailSet(dpStart);</span>
<span class="fc" id="L311">        workingIt = workingSet.iterator();</span>
<span class="fc" id="L312">        dp = null;</span>
        
<span class="fc bfc" id="L314" title="All 2 branches covered.">        if (workingIt.hasNext()) {</span>
            
<span class="fc" id="L316">            dp = workingIt.next();</span>
        }
        
        try {
            Token t;
<span class="fc" id="L321">            boolean done = false;</span>
<span class="fc" id="L322">            dpEnd = dpStart;</span>
            
<span class="fc" id="L324">            synchronized (docLock) {</span>
                
                // we are playing some games with the lexer for
                // efficiency.
                // we could just create a new lexer each time here,
                // but instead,
                // we will just reset it so that it thinks it is
                // starting at the
                // beginning of the document but reporting a funny
                // start position.
                // Reseting the lexer causes the close() method on
                // the reader
                // to be called but because the close() method has
                // no effect on the
                // DocumentReader, we can do this.
<span class="fc" id="L339">                syntaxLexer.reset(documentReader, 0, dpStart</span>
<span class="fc" id="L340">                        .getPosition(), 0);</span>
                // After the lexer has been set up, scroll the
                // reader so that it
                // is in the correct spot as well.
<span class="fc" id="L344">                documentReader.seek(dpStart.getPosition());</span>
                // we will highlight tokens until we reach a good
                // stopping place.
                // the first obvious stopping place is the end of
                // the document.
                // the lexer will return null at the end of the
                // document and wee
                // need to stop there.
<span class="fc" id="L352">                t = syntaxLexer.getNextToken();</span>
<span class="fc" id="L353">            }</span>
            
<span class="fc" id="L355">            this.newPositions.add(dpStart);</span>
            
<span class="fc bfc" id="L357" title="All 4 branches covered.">            while (!done &amp;&amp; t != null) {</span>
                // this is the actual command that colors the stuff.
                // Color stuff with the description of the styles
                // stored in tokenStyles.
<span class="pc bpc" id="L361" title="1 of 2 branches missed.">                if (t.getCharEnd() &lt;= doc.getLength()) {</span>
                    
<span class="fc" id="L363">                    doc.setCharacterAttributes(</span>
<span class="fc" id="L364">                        t.getCharBegin() + this.change,</span>
<span class="fc" id="L365">                        t.getCharEnd() - t.getCharBegin(),</span>
<span class="fc" id="L366">                        TokenStyles.getStyle(t.getDescription()),</span>
                        true
                    );
                    // record the position of the last bit of
                    // text that we colored
<span class="fc" id="L371">                    dpEnd = new DocPosition(t.getCharEnd());</span>
                }
                
<span class="fc" id="L374">                this.lastPosition = t.getCharEnd() + this.change;</span>
                
                // The other more complicated reason for doing no
                // more highlighting
                // is that all the colors are the same from here on
                // out anyway.
                // We can detect this by seeing if the place that
                // the lexer returned
                // to the initial state last time we highlighted is
                // the same as the
                // place that returned to the initial state this
                // time.
                // As long as that place is after the last changed
                // text, everything
                // from there on is fine already.
<span class="pc bpc" id="L389" title="1 of 2 branches missed.">                if (t.getState() == Token.INITIAL_STATE) {</span>
                    
                    // look at all the positions from last time that
                    // are less than or
                    // equal to the current position
<span class="fc bfc" id="L394" title="All 4 branches covered.">                    while (dp != null &amp;&amp; dp.getPosition() &lt;= t.getCharEnd()) {</span>
                        
<span class="pc bpc" id="L396" title="1 of 4 branches missed.">                        if (dp.getPosition() == t.getCharEnd() &amp;&amp; dp.getPosition() &gt;= endRequest.getPosition()) {</span>
                            
                            // we have found a state that is the
                            // same
<span class="fc" id="L400">                            done = true;</span>
<span class="fc" id="L401">                            dp = null;</span>
                            
<span class="pc bpc" id="L403" title="1 of 2 branches missed.">                        } else if (workingIt.hasNext()) {</span>
                            
                            // didn't find it, try again.
<span class="nc" id="L406">                            dp = workingIt.next();</span>
                            
                        } else {
                            
                            // didn't find it, and there is no more
                            // info from last
                            // time. This means that we will just
                            // continue
                            // until the end of the document.
<span class="fc" id="L415">                            dp = null;</span>
                        }
                    }
                    
                    // so that we can do this check next time,
                    // record all the
                    // initial states from this time.
<span class="fc" id="L422">                    this.newPositions.add(dpEnd);</span>
                }
                
<span class="fc" id="L425">                synchronized (docLock) {</span>
                    
<span class="fc" id="L427">                    t = syntaxLexer.getNextToken();</span>
<span class="fc" id="L428">                }</span>
            }

            // remove all the old initial positions from the place
            // where
            // we started doing the highlighting right up through
            // the last
            // bit of text we touched.
<span class="fc" id="L436">            workingIt = this.iniPositions.subSet(dpStart, dpEnd).iterator();</span>
<span class="fc bfc" id="L437" title="All 2 branches covered.">            while (workingIt.hasNext()) {</span>
                
<span class="fc" id="L439">                workingIt.next();</span>
<span class="fc" id="L440">                workingIt.remove();</span>
            }

            // Remove all the positions that are after the end of
            // the file.:
<span class="fc" id="L445">            workingIt = this.iniPositions.tailSet(new DocPosition(doc.getLength())).iterator();</span>
<span class="fc bfc" id="L446" title="All 2 branches covered.">            while (workingIt.hasNext()) {</span>
                
<span class="fc" id="L448">                workingIt.next();</span>
<span class="fc" id="L449">                workingIt.remove();</span>
            }

            // and put the new initial positions that we have found
            // on the list.
<span class="fc" id="L454">            this.iniPositions.addAll(this.newPositions);</span>
<span class="fc" id="L455">            this.newPositions.clear();</span>
            
<span class="nc" id="L457">        } catch (IOException e) {</span>
            
<span class="nc" id="L459">            LOGGER.log(LogLevelUtil.IGNORE, e);</span>
<span class="fc" id="L460">        }</span>
        
<span class="fc" id="L462">        synchronized (docLock) {</span>
            
<span class="fc" id="L464">            this.lastPosition = -1;</span>
<span class="fc" id="L465">            this.change = 0;</span>
<span class="fc" id="L466">        }</span>
<span class="fc" id="L467">    }</span>
    
    /**
     * Stop the thread's method run()
     */
    public void stopThread() {
<span class="nc" id="L473">        this.document.clear();</span>
<span class="nc" id="L474">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>